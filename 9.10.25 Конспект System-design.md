### Что такое системное проектирование

#### 1. Определение и суть
**Системное проектирование** — это процесс создания:
- **Архитектуры** системы
- **Интерфейсов** взаимодействия
- **Модели данных**
Цель — построение системы, удовлетворяющей конкретным бизнес-требованиям.
#### 2. Ключевые характеристики
- **Системный подход**: охват всех уровней от инфраструктуры до хранения данных
- **Комплексность**: требуется продумывать все компоненты системы
- **Эффективность**: создание оптимальных решений для бизнес-задач
#### 3. Практическая ценность
Преимущества правильного проектирования:
- **Стратегические решения**: принятие ключевых архитектурных решений на ранних этапах
- **Масштабируемость**: возможность легко развивать систему при росте нагрузки
- **Снижение рисков**: выявление проблем до начала реализации
- **Экономия ресурсов**: предотвращение дорогостоящих изменений в будущем
#### 4. Роль в разработке
Проектирование систем — это фундаментальный этап, который:
- Определяет архитектурные принципы системы
- Обеспечивает согласованность всех компонентов
- Позволяет управлять изменениями по мере развития системы

### IP-адреса
#### 1. Основные понятия
**IP-адрес** — уникальный идентификатор устройства в сети Интернет или локальной сети.
- **Internet Protocol** — набор правил передачи данных
- Позволяет идентифицировать устройства и передавать информацию
- Содержит информацию о местоположении устройства
#### 2. Версии IP-адресов
**IPv4**
- 32-битная числовая запись (точечно-десятичная)
- Пример: 102.22.192.181
- Ограничение: ~4 миллиарда адресов
**IPv6**
- 128-битная буквенно-цифровая запись (шестнадцатеричная)
- Пример: 2001:0db8:85a3:0000:0000:8a2e:0370:7334
- Огромная емкость: ~340e+36 адресов
#### 3. Типы IP-адресов
**По области действия:**
- **Публичные** — общий адрес для всей сети
- **Приватные** — уникальные адреса для каждого устройства в локальной сети
**По способу назначения:**
- **Статические** — постоянные, назначаются вручную
- **Динамические** — временные, назначаются DHCP-сервером
#### Ключевые особенности:
- Динамические адреса более распространены и экономичны
- Статические адреса надежнее и используются для критических сервисов
- Переход на IPv6 решает проблему нехватки адресов

### Модель OSI
**Модель OSI** — это логическая и концептуальная модель, которая определяет сетевую коммуникацию, используемую системами, открытыми для взаимодействия и соединения с другими системами. Модель взаимодействия открытых систем (OSI) также определяет логическую сеть и эффективно описывает передачу компьютерных пакетов с использованием различных уровней протоколов.

Модель OSI можно рассматривать как универсальный язык для компьютерных сетей. Она основана на концепции разделения системы связи на семь абстрактных уровней, каждый из которых располагается поверх предыдущего.
#### Почему модель OSI важна?
Модель взаимодействия открытых систем (OSI) установила общую терминологию, используемую в сетевых обсуждениях и документации. Это позволяет нам разбирать очень сложный процесс коммуникации и оценивать его компоненты.

Хотя эта модель не реализована напрямую в сетях TCP/IP, которые наиболее распространены сегодня, она всё равно может помочь нам в следующем:
- Упростить диагностику проблем и помочь выявить угрозы на всех уровнях.
- Стимулировать производителей оборудования создавать сетевыe продукты, которые могут взаимодействовать друг с другом через сеть.
- Быть необходимой для развития мышления, ориентированного на безопасность в первую очередь.
- Разделять сложные функции на более простые компоненты.
#### Уровни
Семь абстрактных уровней модели OSI можно определить следующим образом, сверху вниз:
![[Pasted image 20251012193840.png]]
**Прикладной уровень (Application)**  
Это единственный уровень, который напрямую взаимодействует с данными от пользователя. Такие программные приложения, как веб-браузеры и почтовые клиенты, полагаются на прикладной уровень для инициирования связи. Но следует понимать, что клиентские программные приложения не являются частью прикладного уровня; вместо этого прикладной уровень отвечает за протоколы и манипуляцию данными, от которых зависит программное обеспечение для представления пользователю meaningful данных. К протоколам прикладного уровня относятся HTTP, а также SMTP.

**Уровень представления (Presentation)**  
Уровень представления также называют уровнем трансляции. Данные из прикладного уровня извлекаются здесь и обрабатываются в соответствии с требуемым форматом для передачи по сети. Функциями уровня представления являются трансляция, шифрование/дешифрование и сжатие.

**Сеансовый уровень (Session)**  
Это уровень, ответственный за открытие и закрытие связи между двумя устройствами. Время между открытием и закрытием связи называется сеансом. Сеансовый уровень гарантирует, что сеанс остаётся открытым достаточно долго для передачи всех обмениваемых данных, а затем немедленно закрывает сеанс, чтобы избежать浪费 ресурсов. Сеансовый уровень также синхронизирует передачу данных с использованием контрольных точек.

**Транспортный уровень (Transport)**  
Транспортный уровень (также известный как уровень 4) отвечает за сквозную связь между двумя устройствами. Это включает взятие данных от сеансового уровня и разбиение их на фрагменты, называемые сегментами, перед отправкой на сетевой уровень (уровень 3). Он также отвечает за повторную сборку сегментов на принимающем устройстве в данные, которые может потреблять сеансовый уровень.

**Сетевой уровень (Network)**  
Сетевой уровень отвечает за обеспечение передачи данных между двумя разными сетями. Сетевой уровень разбивает сегменты с транспортного уровня на более мелкие единицы, называемые пакетами, на устройстве-отправителе и reassembles эти пакеты на принимающем устройстве. Сетевой уровень также находит лучший физический путь для достижения данных своего назначения; это известно как маршрутизация. Если два взаимодействующих устройства находятся в одной сети, то сетевой уровень не требуется.

**Канальный уровень (Data Link)**  
Канальный уровень очень похож на сетевой уровень, за исключением того, что канальный уровень обеспечивает передачу данных между двумя устройствами в одной сети. Канальный уровень берет пакеты из сетевого уровня и разбивает их на более мелкие части, называемые кадрами.

**Физический уровень (Physical)**  
Этот уровень включает физическое оборудование, участвующее в передаче данных, такое как кабели и коммутаторы. Это также уровень, на котором данные преобразуются в битовый поток, который представляет собой строку из 1 и 0. Физический уровень обоих устройств также должен согласовывать convention сигнала, чтобы 1 можно было отличить от 0 на обоих устройствах.

### TCP и UDP
#### TCP
**Протокол управления передачей (TCP)** является соединением-ориентированным. Это означает, что после установления соединения данные могут передаваться в обоих направлениях. TCP имеет встроенные системы для проверки ошибок и гарантирует, что данные будут доставлены в том порядке, в котором они были отправлены. Это делает его идеальным протоколом для передачи такой информации, как статичные изображения, файлы данных и веб-страницы.
[![tcp](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/tcp.png)]
Однако, хотя TCP инстинктивно надежен, его механизмы обратной связи также приводят к большим накладным расходам, что означает большее использование доступной пропускной способности сети.
#### UDP
**Протокол пользовательских датаграмм (UDP)** — это более простой, не требующий установления соединения интернет-протокол, в котором не требуются услуги проверки ошибок и восстановления. В UDP нет накладных расходов на установление соединения, поддержание соединения или завершение соединения. Данные непрерывно отправляются получателю, независимо от того, получает он их или нет.
[![udp](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/udp.png)]
Его в значительной степени предпочитают для коммуникаций в реальном времени, таких как широковещательная или многоадресная сетевая передача. Следует использовать UDP вместо TCP, когда нам нужна минимальная задержка, а запоздалые данные хуже, чем потеря данных.
#### Сравнение TCP и UDP
TCP — это протокол, ориентированный на соединение, тогда как UDP — это протокол без установления соединения. Ключевое различие между TCP и UDP — скорость, так как TCP сравнительно медленнее, чем UDP. В целом, UDP — это гораздо более быстрый, простой и эффективный протокол, однако повторная передача потерянных пакетов данных возможна только с TCP.

TCP обеспечивает упорядоченную доставку данных от пользователя к серверу (и наоборот), тогда как UDP не предназначен для сквозной связи и не проверяет готовность получателя.

| Характеристика           | TCP                                            | UDP                                       |
| ------------------------ | ---------------------------------------------- | ----------------------------------------- |
| Соединение               | Требует установленного соединения              | Протокол без установления соединения      |
| Гарантированная доставка | Может гарантировать доставку данных            | Не может гарантировать доставку данных    |
| Повторная передача       | Возможна повторная передача потерянных пакетов | Нет повторной передачи потерянных пакетов |
| Скорость                 | Медленнее, чем UDP                             | Быстрее, чем TCP                          |
| Широковещание            | Не поддерживает широковещание                  | Поддерживает широковещание                |
| Примеры использования    | HTTPS, HTTP, SMTP, POP, FTP и т.д.             | Видеостриминг, DNS, VoIP и т.д.           |

### Система доменных имен (DNS)

Ранее мы изучали IP-адреса, которые позволяют компьютерам соединяться друг с другом. Однако людям удобнее работать с именами, а не с числами. Запомнить имя типа google.com гораздо проще, чем что-то вроде 122.250.192.232.

Это подводит нас к **системе доменных имен (DNS)** — иерархической и децентрализованной системе именования, которая преобразует удобные для человека доменные имена в IP-адреса.

#### Как работает DNS
[![Как_работает_DNS](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/domain-name-system/how-dns-works.png)]
Процесс DNS-поиска включает восемь шагов:
1. Клиент вводит example.com в браузере, запрос поступает в интернет и принимается DNS-резолвером
2. Резолвер рекурсивно запрашивает корневой DNS-сервер
3. Корневой сервер отвечает резолверу адресом сервера доменов верхнего уровня (TLD)
4. Резолвер запрашивает TLD-сервер .com
5. TLD-сервер отвечает IP-адресом доменного сервера имён example.com
6. Рекурсивный резолвер отправляет запрос доменному серверу имён
7. Доменный сервер возвращает резолверу IP-адрес для example.com
8. DNS-резолвер отвечает веб-браузеру IP-адресом запрошенного домена
После разрешения IP-адреса клиент может запрашивать контент с полученного IP-адреса.
#### Типы серверов
Рассмотрим четыре ключевые группы серверов, составляющие инфраструктуру DNS:

**DNS-резолвер**
- Первая остановка в DNS-запросе
- Выступает посредником между клиентом и DNS-сервером имён
- Отвечает кэшированными данными или выполняет серию запросов
- Отправляет ответ клиенту с запрошенным IP-адресом

**Корневой DNS-сервер**
- Принимает запросы резолвера с доменными именами
- Направляет резолвер к TLD-серверу на основе расширения домена
- Управляется организацией ICANN
- Существует 13 типов корневых серверов с множественными копиями по всему миру

**TLD-сервер имён**
- Содержит информацию обо всех доменных именах с общим расширением (.com, .net и т.д.)
- Управляется организацией IANA
- Две основные группы:
  - Общие домены верхнего уровня: .com, .org, .net, .edu, .gov
  - Национальные домены: .uk, .us, .ru, .jp

**Авторитативный DNS-сервер**
- Финальный шаг в поиске IP-адреса
- Содержит специфическую информацию о своём доменном имени
- Предоставляет IP-адрес из DNS A-записи или CNAME-псевдоним
- При невозможности найти домен возвращает сообщение NXDOMAIN
#### Типы запросов
**Рекурсивный**
- DNS-сервер должен ответить либо запрошенной записью, либо сообщением об ошибке

**Итеративный**
- DNS-резолвер возвращает лучший доступный ответ
- При отсутствии записи направляет клиента к другому серверу
- Клиент повторяет запрос к указанному серверу

**Нерекурсивный**
- Резолвер уже знает ответ
- Немедленно возвращает DNS-запись из кэша или авторитативного сервера
- Не требует дополнительных раундов запросов
#### Типы записей
DNS-записи — это инструкции на авторитативных DNS-серверах, содержащие информацию о домене.
**Основные типы записей:**
- **A (Address record)**: Содержит IPv4-адрес домена
- **AAAA**: Содержит IPv6-адрес домена
- **CNAME (Canonical Name)**: Перенаправляет на другой домен (без IP-адреса)
- **MX (Mail exchanger)**: Направляет почту на почтовый сервер
- **TXT (Text Record)**: Позволяет хранить текстовые заметки
- **NS (Name Server)**: Указывает сервер имён для DNS-записи
- **SOA (Start of Authority)**: Содержит административную информацию о домене
- **SRV (Service Location)**: Указывает порт для специфических сервисов
- **PTR (Reverse-lookup Pointer)**: Предоставляет доменное имя при обратном поиске
- **CERT (Certificate record)**: Хранит сертификаты открытых ключей
#### Поддомены
Поддомен — дополнительная часть основного доменного имени, используемая для логического разделения сайта на разделы.
**Пример**: blog.example.com
- blog — поддомен
- example — первичный домен
- .com — домен верхнего уровня
#### DNS-зоны
DNS-зона — отдельная часть доменного пространства, делегированная юридическому лицу, которое отвечает за её обслуживание. DNS-зона также является административной функцией, позволяющей детально управлять компонентами DNS.
#### DNS-кэширование
DNS-кэш — временная база данных, поддерживаемая операционной системой, которая содержит записи о недавних посещениях сайтов. Каждая DNS-запись имеет "время жизни" (TTL), указывающее, как долго запись может храниться в кэше.
#### Обратный DNS
Обратный DNS-поиск — запрос доменного имени, связанного с данным IP-адресом. Использует PTR-записи. Широко применяется почтовыми серверами для проверки легитимности отправителей.
#### Примеры решений
Популярные управляемые DNS-решения:
- Route53
- Cloudflare DNS
- Google Cloud DNS
- Azure DNS
- NS1

### Балансировка нагрузки

Балансировка нагрузки позволяет распределять входящий сетевой трафик между несколькими ресурсами, обеспечивая высокую доступность и надежность путем отправки запросов только к работающим ресурсам. Это дает гибкость для добавления или уменьшения ресурсов в зависимости от спроса.
[![Балансирование_нагрузки](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer.png)]
Для обеспечения дополнительной масштабируемости и избыточности мы можем организовать балансировку нагрузки на каждом уровне нашей системы:
[![Балансировка_нагрузки](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer-layers.png)]
#### Зачем это нужно?
Современные высоконагруженные веб-сайты должны обслуживать сотни тысяч или даже миллионы одновременных запросов. Для экономически эффективного масштабирования обычно требуется добавление серверов.

Балансировщик нагрузки располагается перед серверами и маршрутизирует клиентские запросы между всеми серверами, способными их обработать, максимизируя скорость и использование ресурсов. Это предотвращает перегрузку отдельных серверов и обеспечивает перенаправление трафика при сбоях.
#### Распределение рабочей нагрузки
Основные варианты распределения:
- **На основе хоста**: распределение по имени хоста
- **На основе пути**: использование полного URL для маршрутизации
- **На основе содержимого**: анализ содержимого запроса, включая параметры
#### Уровни работы
**Сетевой уровень (уровень 4)**
- Маршрутизация на основе сетевой информации (IP-адреса)
- Высокая скорость работы
- Не поддерживает маршрутизацию на основе содержимого

**Прикладной уровень (уровень 7)**
- Полный анализ запросов
- Маршрутизация на основе содержимого
- Более интеллектуальное управление нагрузкой
#### Типы балансировщиков
**Программные**
- Проще в развертывании, более экономичны
- Гибкая конфигурация под конкретные нужды
- Требуют больше усилий для настройки
- Доступны как устанавливаемые решения или облачные сервисы

**Аппаратные**
- Основаны на физическом оборудовании
- Обрабатывают большой объем трафика
- Высокая стоимость, ограниченная гибкость
- Требуют обновления прошивки

**DNS-балансировка**
- Распределение запросов через настройки DNS
- Проблемы: не проверяет доступность серверов
- Всегда возвращает одинаковый набор IP-адресов
#### Алгоритмы маршрутизации
- **Round-robin**: циклическое распределение запросов
- **Weighted Round-robin**: учет характеристик серверов через веса
- **Least Connections**: отправка на сервер с наименьшим числом подключений
- **Least Response Time**: учет времени ответа и активных подключений
- **Least Bandwidth**: измерение трафика в Mbps
- **Hashing**: распределение на основе ключа (IP-адрес, URL)
#### Преимущества
- **Масштабируемость**
- **Избыточность**
- **Гибкость**
- **Эффективность**
- **Предотвращение простоев**
#### Резервирование
Балансировщик нагрузки может быть единой точкой отказа. Для решения этой проблемы используются кластеры из нескольких балансировщиков с автоматическим переключением при сбоях.
#### Ключевые функции
- **Автоматическое масштабирование**
- **Sticky sessions** - привязка пользователя к серверу
- **Health checks** - проверка работоспособности ресурсов
- **Поддержка шифрования (TLS/SSL)**
- **Кэширование ответов**
- **Логирование и трассировка запросов**
- **Сжатие данных**
- **Перенаправления и статические ответы**
#### Популярные решения
- Amazon Elastic Load Balancing
- Azure Load Balancing
- GCP Load Balancing
- DigitalOcean Load Balancer
- Nginx
- HAProxy

### Кэширование

#### Основная концепция

**Кэш** — это быстрая память, предназначенная для увеличения производительности извлечения данных за счет сокращения обращений к более медленным уровням хранения. Кэш хранит подмножество данных временно, в отличие от баз данных, где данные обычно полные и постоянные.

**Принцип работы**: использование локальности ссылок — «недавно запрошенные данные, вероятно, будут запрошены снова».

#### Иерархия памяти

Кэш организован в иерархии уровней (L1, L2, L3 и т.д.):
- **L1**: Самый быстрый, но наименьший по объему
- **L2/L3**: Медленнее, но больше по объему
- Данные читаются и записываются блоками с тегами для идентификации

#### Кэш-попадания и промахи

**Кэш-попадание**:
- Данные успешно найдены в кэше
- **Горячий кэш**: данные из L1 (максимальная скорость)
- **Теплый кэш**: данные из L2/L3
- **Холодный кэш**: данные из нижних уровней (медленнее, но все же попадание)

**Кэш-промах**:
- Данные не найдены в кэше
- Информация переносится и записывается в кэш

#### Инвалидация кэша

Процесс объявления записей кэша недействительными с их последующим удалением или заменой. Существует три стратегии записи:

**Сквозная запись (Write-through)**:
- Данные записываются одновременно в кэш и базу данных
- ✅ Быстрое чтение, полная согласованность
- ❌ Высокая задержка записи

**Обходная запись (Write-around)**:
- Запись идет напрямую в базу данных, минуя кэш
- ✅ Снижение задержки записи
- ❌ Увеличение кэш-промахов

**Обратная запись (Write-back)**:
- Запись только в кэш с последующей асинхронной синхронизацией
- ✅ Низкая задержка, высокая пропускная способность
- ❌ Риск потери данных при сбое

#### Политики вытеснения

- **FIFO** (First In First Out): первым пришел — первым ушел
- **LIFO** (Last In First Out): последним пришел — первым ушел
- **LRU** (Least Recently Used): реже всего использовавшиеся
- **MRU** (Most Recently Used): чаще всего использовавшиеся
- **LFU** (Least Frequently Used): реже всего используемые
- **RR** (Random Replacement): случайное вытеснение

#### Распределенный кэш

Объединяет оперативную память нескольких компьютеров в единое кэш-хранилище, позволяя преодолеть ограничения памяти одного сервера.

#### Глобальный кэш

Единый общий кэш для всех узлов приложения. При промахе кэш самостоятельно находит недостающие данные в основном хранилище.

#### Сценарии использования

- Кэширование базы данных
- Сети доставки контента (CDN)
- DNS-кэширование
- API-кэширование

#### Когда не следует использовать кэш

- Когда доступ к кэшу занимает столько же времени, как к основному хранилищу
- При низкой повторяемости запросов (случайный доступ)
- При частом изменении данных
- Не следует использовать кэш как постоянное хранилище

#### Преимущества

- Улучшение производительности
- Снижение задержки
- Снижение нагрузки на базу данных
- Снижение сетевых затрат
- Увеличение пропускной способности чтения

#### Популярные технологии

- Redis
- Memcached
- Amazon ElastiCache
- Aerospike