### **Базы данных и СУБД** ###

**Что такое база данных?**

База данных — это упорядоченная коллекция структурированной информации или данных, обычно хранящаяся в электронном виде в компьютерной системе. Базой данных обычно управляет Система Управления Базами Данных (СУБД). Вместе данные, СУБД и связанные с ними приложения называются системой баз данных, часто сокращаемой до просто "база данных".

**Что такое СУБД?**

База данных обычно требует комплексной программы для работы с базами данных, известной как Система Управления Базами Данных (СУБД). СУБД служит интерфейсом между базой данных и ее конечными пользователями или программами, позволяя пользователям извлекать, обновлять и управлять тем, как информация организована и оптимизирована. СУБД также обеспечивает контроль и управление базами данных, позволяя выполнять различные административные операции, такие как мониторинг производительности, настройка, резервное копирование и восстановление.

---

#### **Компоненты** ####

Вот некоторые общие компоненты, встречающиеся в различных базах данных:

* **Схема (Schema)** 
	Роль схемы — определить структуру данных и указать, какие данные могут находиться где. Схемы могут быть строго соблюдаемыми во всей базе данных, слабо соблюдаемыми в части базы данных или их может не существовать вовсе.

* **Таблица (Table)**
	Каждая таблица содержит различные столбцы, как в электронной таблице. Таблица может иметь всего два столбца и до сотни или более столбцов, в зависимости от вида информации, помещаемой в таблицу.

* **Столбец (Column)**
	Столбец содержит набор значений данных определенного типа, по одному значению для каждой строки базы данных. Столбец может содержать текстовые значения, числа, перечисления (enums), временные метки и т.д.

* **Строка (Row)**
	Данные в таблице записываются в строках. В таблице могут быть тысячи или миллионы строк, содержащих любую конкретную информацию.

---

#### **Типы** ####

Ниже приведены различные типы баз данных:

*   SQL
*   NoSQL
*   Документная (Document)
*   Ключ-значение (Key-value)
*   Графовая (Graph)
*   Временных рядов (Timeseries)
*   Широкостолбцовая (Wide column)
*   Многомодельная (Multi-model)

Базы данных SQL и NoSQL — это обширные темы, и они будут обсуждаться отдельно в разделах "SQL базы данных" и "NoSQL базы данных". Узнайте, как они сравниваются друг с другом, в разделе "SQL vs NoSQL базы данных".

---

#### **Проблемы (Challenges)** ####

Некоторые распространенные проблемы при работе с базами данных в крупном масштабе:

*   **Обработка значительного увеличения объема данных:** Взрывной рост данных, поступающих от датчиков, подключенных устройств и десятков других источников.
*   **Обеспечение безопасности данных:** Утечки данных происходят повсеместно сегодня, как никогда важно обеспечить безопасность данных, но при этом их легкую доступность для пользователей.
*   **Соответствие спросу:** Компаниям нужен реальный доступ к своим данным для поддержки своевременного принятия решений и использования новых возможностей.
*   **Управление и обслуживание базы данных и инфраструктуры:** По мере усложнения баз данных и роста объемов данных компании сталкиваются с затратами на найм дополнительных специалистов для управления своими базами данных.
*   **Снятие ограничений на масштабируемость:** Бизнес должен расти, чтобы выжить, и его управление данными должно расти вместе с ним. Но очень сложно предсказать, какой объем мощностей потребуется компании, особенно с локальными (on-premises) базами данных.
*   **Обеспечение требований к резидентности данных, суверенитету данных или задержкам:** Некоторым организациям подходят сценарии использования, которые лучше запускать локально. В таких случаях идеально подходят инженерные системы, предварительно сконфигурированные и оптимизированные для работы с базой данных.

---

### **SQL базы данных**

**SQL (или реляционная) база данных** — это набор элементов данных с предопределенными отношениями между ними. Эти элементы организованы в виде набора таблиц со столбцами и строками. Таблицы используются для хранения информации об объектах, представленных в базе данных. Каждый столбец в таблице содержит данные определенного типа, а поле хранит фактическое значение атрибута. Строки в таблице представляют собой набор связанных значений одного объекта или сущности.

Каждая строка в таблице может быть помечена уникальным идентификатором, называемым первичным ключом, а строки из нескольких таблиц могут быть связаны с помощью внешних ключей. К этим данным можно получить доступ множеством различных способов без реорганизации самих таблиц базы данных. SQL базы данных обычно следуют модели согласованности ACID.

**Материализованные представления (Materialized views)**
Материализованное представление — это предварительно вычисленный набор данных, полученный из спецификации запроса и сохраненный для последующего использования. Поскольку данные предварительно вычислены, запрос к материализованному представлению выполняется быстрее, чем выполнение запроса к базовой таблице представления. Эта разница в производительности может быть значительной, если запрос выполняется часто или является достаточно сложным.

Это также позволяет создавать подмножества данных и повышает производительность сложных запросов, выполняющихся на больших наборах данных, что снижает нагрузку на сеть. Существуют и другие применения материализованных представлений, но в основном они используются для повышения производительности и репликации.

**Проблема N+1 запросов (N+1 query problem)**
Проблема N+1 запросов возникает, когда уровень доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно было бы получить при выполнении основного SQL-запроса. Чем больше значение N, тем больше запросов будет выполнено и тем больше влияние на производительность.

Это часто наблюдается в GraphQL и ORM (Object-Relational Mapping) инструментах, и ее можно решить путем оптимизации SQL-запроса или использования dataloader, который группирует последовательные запросы и выполняет один запрос данных "под капотом".

**Преимущества**
Давайте посмотрим на некоторые преимущества использования реляционных баз данных:
*   Простота и точность
*   Доступность
*   Согласованность данных
*   Гибкость

**Недостатки**
Ниже приведены недостатки реляционных баз данных:
*   Дорогое обслуживание
*   Сложная эволюция схемы
*   Потери производительности (соединения, денормализация и т.д.)
*   Сложность масштабирования из-за плохой горизонтальной масштабируемости

**Примеры**
Вот некоторые часто используемые реляционные базы данных:
*   PostgreSQL
*   MySQL
*   MariaDB
*   Amazon Aurora

---

### **NoSQL базы данных** ###

**NoSQL** — это широкая категория, включающая любую базу данных, которая не использует SQL в качестве основного языка доступа к данным. Эти типы баз данных также иногда называют нереляционными. В отличие от реляционных баз данных, данные в NoSQL базе данных не должны соответствовать предопределенной схеме. NoSQL базы данных следуют модели согласованности BASE.

Ниже приведены различные типы NoSQL баз данных:

**Документная (Document)**
Документная база данных (также известная как документо-ориентированная база данных или хранилище документов) — это база данных, которая хранит информацию в документах. Это базы данных общего назначения, которые обслуживают различные случаи использования как для транзакционных, так и для аналитических приложений.

*   *Преимущества:* Интуитивно понятная и гибкая, Легкое горизонтальное масштабирование, Без схемы (Schemaless)
*   *Недостатки:* Без схемы (может быть недостатком), Нереляционная
*   *Примеры:* MongoDB, Amazon DocumentDB, CouchDB

**Ключ-значение (Key-value)**
Один из самых простых типов NoSQL баз данных, базы данных "ключ-значение" сохраняют данные как группу пар "ключ-значение", состоящих из двух элементов данных каждый. Их также иногда называют хранилищем "ключ-значение".

*   *Преимущества:* Простота и производительность, Высокая масштабируемость для больших объемов трафика, Управление сеансами, Оптимизированные поисковые запросы
*   *Недостатки:* Базовые CRUD операции, Значения нельзя фильтровать, Отсутствие возможностей индексирования и сканирования, Не оптимизированы для сложных запросов
*   *Примеры:* Redis, Memcached, Amazon DynamoDB, Aerospike

**Графовая (Graph)**
Графовая база данных — это NoSQL база данных, которая использует графовые структуры для семантических запросов с узлами, ребрами и свойствами для представления и хранения данных вместо таблиц или документов.

Граф связывает элементы данных в хранилище с набором узлов и ребер, где ребра представляют отношения между узлами. Отношения позволяют напрямую связывать данные в хранилище и, во многих случаях, извлекать их одной операцией.

*   *Преимущества:* Скорость запросов, Гибкость и адаптивность, Явное представление данных
*   *Недостатки:* Сложность, Отсутствие стандартизированного языка запросов
*   *Примеры использования:* Обнаружение мошенничества, Рекомендательные системы, Социальные сети, Картирование сетей
*   *Примеры:* Neo4j, ArangoDB, Amazon Neptune, JanusGraph

**Временных рядов (Time series)**
База данных временных рядов — это база данных, оптимизированная для данных с временными метками, или данных временных рядов.

*   *Преимущества:* Быстрая вставка и извлечение, Эффективное хранение данных
*   *Примеры использования:* Данные IoT, Анализ метрик, Мониторинг приложений, Анализ финансовых тенденций
*   *Примеры:* InfluxDB, Apache Druid

**Широкостолбцовая (Wide column)**
Широкостолбцовые базы данных, также известные как широкостолбцовые хранилища, не зависят от схемы. Данные хранятся в семействах столбцов, а не в строках и столбцах.

*   *Преимущества:* Высокая масштабируемость, могут обрабатывать петабайты данных, Идеальны для приложений больших данных в реальном времени
*   *Недостатки:* Дорогостоящие, Увеличение времени записи
*   *Примеры использования:* Бизнес-аналитика, Хранение данных на основе атрибутов
*   *Примеры:* BigTable, Apache Cassandra, ScyllaDB

**Многомодельная (Multi-model)**
Многомодельные базы данных объединяют различные модели баз данных (т.е. реляционные, графовые, "ключ-значение", документные и т.д.) в единый интегрированный бэкенд. Это означает, что они могут accommodate различные типы данных, индексы, запросы и хранить данные более чем в одной модели.

*   *Преимущества:* Гибкость, Подходят для сложных проектов, Согласованность данных
*   *Недостатки:* Сложность, Менее зрелые
*   *Примеры:* ArangoDB, Azure Cosmos DB, Couchbase

---

### **SQL vs NoSQL базы данных** ###

В мире баз данных существует два основных типа решений: SQL (реляционные) и NoSQL (нереляционные) базы данных. Оба они различаются по способу построения, типу информации, которую они хранят, и способу ее хранения. Реляционные базы данных структурированы и имеют предопределенные схемы, в то время как нереляционные базы данных неструктурированы, распределены и имеют динамическую схему.

**Высокоуровневые различия**
Вот некоторые высокоуровневые различия между SQL и NoSQL:

*   **Хранение (Storage):**
    *   SQL хранит данные в таблицах, где каждая строка представляет сущность, а каждый столбец представляет точку данных об этой сущности.
    *   NoSQL базы данных имеют различные модели хранения данных, такие как "ключ-значение", графы, документы и т.д.
*   **Схема (Schema):**
    *   В SQL каждая запись соответствует фиксированной схеме, то есть столбцы должны быть определены и выбраны до ввода данных, и каждая строка должна иметь данные для каждого столбца. Схему можно изменить позже, но это involves изменение базы данных с использованием миграций.
    *   В NoSQL схемы динамические. Поля можно добавлять "на лету", и каждая запись (или ее эквивалент) не обязана содержать данные для каждого поля.
*   **Запросы (Querying):**
    *   SQL базы данных используют SQL (структурированный язык запросов) для определения и манипулирования данными, который очень мощный.
    *   В NoSQL базе данных запросы сосредоточены на коллекции документов. Разные базы данных имеют разный синтаксис для запросов.
*   **Масштабируемость (Scalability):**
    *   В большинстве распространенных ситуаций SQL базы данных масштабируются вертикально, что может стать очень дорогим. Возможно масштабировать реляционную базу данных на несколько серверов, но это сложный и трудоемкий процесс.
    *   С другой стороны, NoSQL базы данных масштабируются горизонтально, то есть мы можем легко добавлять больше серверов в нашу инфраструктуру NoSQL базы данных для обработки большого трафика. Любое дешевое стандартное оборудование или облачные инстансы могут размещать NoSQL базы данных, что делает их намного более рентабельными по сравнению с вертикальным масштабированием. Многие технологии NoSQL также автоматически распределяют данные по серверам.
*   **Надежность (Reliability):**
    *   Подавляющее большинство реляционных баз данных совместимы с ACID. Поэтому, когда речь идет о надежности данных и безопасной гарантии выполнения транзакций, SQL базы данных все еще являются лучшим выбором.
    *   Большинство NoSQL решений жертвуют совместимостью с ACID ради производительности и масштабируемости.

**Причины выбора**
Как всегда, мы должны выбирать технологию, которая лучше соответствует требованиям. Итак, давайте рассмотрим некоторые причины для выбора базы данных на основе SQL или NoSQL:

*   **Для SQL:**
    *   Структурированные данные со строгой схемой
    *   Реляционные данные
    *   Необходимость сложных соединений (joins)
    *   Транзакции
    *   Очень быстрый поиск по индексу
*   **Для NoSQL:**
    *   Динамическая или гибкая схема
    *   Нереляционные данные
    *   Отсутствие необходимости в сложных соединениях
    *   Очень интенсивная рабочая нагрузка по данным
    *   Очень высокая пропускная способность для IOPS

---

### **Репликация базы данных (Database Replication)** ###

**Репликация** — это процесс, включающий обмен информацией для обеспечения согласованности между избыточными ресурсами, такими как несколько баз данных, для повышения надежности, отказоустойчивости или доступности.

**Реplication "Ведущий-Ведомый" (Master-Slave Replication)**
Ведущий узел (master) обслуживает операции чтения и записи, реплицируя операции записи на один или несколько ведомых узлов (slaves), которые обслуживают только операции чтения. Ведомые узлы также могут реплицировать данные на дополнительные ведомые узлы в древовидной структуре. Если ведущий узел выходит из строя, система может продолжать работать в режиме "только чтение" до тех пор, пока ведомый узел не будет повышен до ведущего или не будет provisioned новый ведущий узел.

*   *Преимущества:*
    *   Резервное копирование всей базы данных практически не влияет на ведущий узел.
    *   Приложения могут читать с ведомого узла(ов) без воздействия на ведущий.
    *   Ведомые узлы могут быть отключены и повторно синхронизированы с ведущим без какого-либо простоя.
*   *Недостатки:*
    *   Репликация добавляет больше оборудования и дополнительную сложность.
    *   Простой и возможная потеря данных при отказе ведущего узла.
    *   Все операции записи также должны выполняться на ведущий узел в архитектуре "ведущий-ведомый".
    *   Чем больше ведомых узлов для чтения, тем больше данных нужно реплицировать, что увеличивает задержку репликации (replication lag).

**Реplication "Ведущий-Ведущий" (Master-Master Replication)**
Оба ведущих узла обслуживают операции чтения/записи и координируются друг с другом. Если любой из ведущих узлов выходит из строя, система может продолжать работать с чтением и записью.

*   *Преимущества:*
    *   Приложения могут читать с обоих ведущих узлов.
    *   Распределяет нагрузку записи между обоими ведущими узлами.
    *   Простой, автоматический и быстрый переход на резервный сервер (failover).
*   *Недостатки:*
    *   Не так прост в настройке и развертывании, как "ведущий-ведомый".
    *   Или слабая согласованность (loosely consistent), или увеличенная задержка записи из-за синхронизации.
    *   Разрешение конфликтов (Conflict resolution) вступает в игру по мере добавления большего количества узлов записи и увеличения задержки.

**Синхронная и асинхронная репликация (Synchronous vs Asynchronous replication)**
Основное различие между синхронной и асинхронной репликацией заключается в том, как данные записываются в реплику. При синхронной репликации данные записываются в основное хранилище и в реплику одновременно. Таким образом, основная копия и реплика должны всегда оставаться синхронизированными.

В отличие от этого, асинхронная репликация копирует данные в реплику после того, как данные уже записаны в основное хранилище. Хотя процесс репликации может происходить почти в реальном времени, чаще репликация происходит по расписанию, и она более рентабельна.

---

### **Индексы (Indexes)** ###

Индексы хорошо известны, когда речь идет о базах данных; они используются для повышения скорости операций извлечения данных в хранилище данных. Индекс делает компромисс между увеличением накладных расходов на хранение и замедлением операций записи (поскольку мы должны не только записывать данные, но и обновлять индекс) ради преимущества более быстрого чтения. Индексы используются для быстрого поиска данных без необходимости проверять каждую строку в таблице базы данных. Индексы могут быть созданы с использованием одного или нескольких столбцов таблицы базы данных, обеспечивая основу как для быстрого произвольного поиска, так и для эффективного доступа к упорядоченным записям.

**Индекс** — это структура данных, которую можно воспринимать как оглавление, которое указывает нам на местоположение, где находятся фактические данные. Поэтому, когда мы создаем индекс для столбца таблицы, мы сохраняем этот столбец и указатель на всю строку в индексе. Индексы также используются для создания различных представлений одних и тех же данных. Для больших наборов данных это отличный способ указать различные фильтры или схемы сортировки без необходимости создания нескольких дополнительных копий данных.

Одно качество, которым могут обладать индексы базы данных, — это то, что они могут быть плотными (dense) или разреженными (sparse). Каждое из этих качеств индекса имеет свои компромиссы. Давайте посмотрим, как работает каждый тип индекса:

**Плотный индекс (Dense Index)**
В плотном индексе запись индекса создается для каждой строки таблицы. Записи можно найти напрямую, поскольку каждая запись индекса содержит значение ключа поиска и указатель на фактическую запись.

Плотные индексы требуют больше обслуживания, чем разреженные индексы, во время записи. Поскольку каждая строка должна иметь запись, база данных должна поддерживать индекс при вставках, обновлениях и удалениях. Наличие записи для каждой строки также означает, что плотные индексы потребуют больше памяти. Преимущество плотного индекса заключается в том, что значения можно быстро найти с помощью простого бинарного поиска. Плотные индексы также не накладывают никаких требований к упорядочиванию данных.

**Разреженный индекс (Sparse Index)**
В разреженном индексе записи индекса создаются только для некоторых записей.

Разреженные индексы требуют меньше обслуживания, чем плотные индексы, во время записи, поскольку они содержат только подмножество значений. Это более легкое бремя обслуживания означает, что вставки, обновления и удаления будут быстрее. Меньшее количество записей также означает, что индекс будет использовать меньше памяти. Поиск данных медленнее, поскольку за бинарным поиском обычно следует сканирование страницы. Разреженные индексы также являются необязательными при работе с упорядоченными данными.

---

### **Нормализация и денормализация (Normalization and Denormalization)** ###

**Термины**
Прежде чем мы пойдем дальше, давайте рассмотрим некоторые часто используемые термины в нормализации и денормализации.

*   **Ключи (Keys)**
    *   **Первичный ключ (Primary key):** Столбец или группа столбцов, которые можно использовать для однозначной идентификации каждой строки таблицы.
    *   **Составной ключ (Composite key):** Первичный ключ, состоящий из нескольких столбцов.
    *   **Суперключ (Super key):** Набор всех ключей, которые могут однозначно идентифицировать все строки в таблице.
    *   **Кандидатный ключ (Candidate key):** Атрибуты, которые однозначно идентифицируют строки в таблице.
    *   **Внешний ключ (Foreign key):** Это ссылка на первичный ключ другой таблицы.
    *   **Альтернативный ключ (Alternate key):** Ключи, не являющиеся первичными, известны как альтернативные ключи.
    *   **Суррогатный ключ (Surrogate key):** Системно сгенерированное значение, которое однозначно идентифицирует каждую запись в таблице, когда никакой другой столбец не мог удерживать свойства первичного ключа.
*   **Зависимости (Dependencies)**
    *   **Частичная зависимость (Partial dependency):** Возникает, когда первичный ключ определяет некоторые другие атрибуты.
    *   **Функциональная зависимость (Functional dependency):** Это отношение, которое существует между двумя атрибутами, обычно между первичным ключом и неключевым атрибутом в таблице.
    *   **Транзитивная функциональная зависимость (Transitive functional dependency):** Возникает, когда некоторый неключевой атрибут определяет некоторый другой атрибут.
*   **Аномалии (Anomalies)**
    Аномалия базы данных происходит, когда есть недостаток в базе данных из-за неправильного планирования или хранения всего в плоской базе данных. Это обычно решается процессом нормализации.

    Существует три типа аномалий базы данных:
    *   **Аномалия вставки (Insertion anomaly):** Возникает, когда мы не можем вставить определенные атрибуты в базу данных без наличия других атрибутов.
    *   **Аномалия обновления (Update anomaly):** Возникает в случае избыточности данных и частичного обновления. Другими словами, правильное обновление базы данных требует других действий, таких как добавление, удаление или и то, и другое.
    *   **Аномалия удаления (Deletion anomaly):** Возникает, когда удаление некоторых данных требует удаления других данных.

**Пример**
Рассмотрим следующую ненормализованную таблицу:

| ID  | Name   | Role              | Team |
| :-- | :----- | :---------------- | ---- |
| 1   | Peter  | Software Engineer | A    |
| 2   | Brian  | DevOps Engineer   | B    |
| 3   | Hailey | Product Manager   | C    |
| 4   | Hailey | Product Manager   | C    |
| 5   | Steve  | Frontend Engineer | D    |

Представим, что мы наняли нового человека "Джона", но его, возможно, еще не назначили в команду немедленно. Это вызовет аномалию вставки, так как атрибут "команда" еще отсутствует.

Далее, допустим, Хейли из Команды C получила повышение. Чтобы отразить это изменение в базе данных, нам нужно будет обновить 2 строки для поддержания согласованности, что может вызвать аномалию обновления.

Наконец, мы хотим удалить Команду B, но для этого нам также нужно удалить дополнительную информацию, такую как имя и роль, это пример аномалии удаления.

**Нормализация (Normalization)**
Нормализация — это процесс организации данных в базе данных. Это включает создание таблиц и установление отношений между этими таблицами согласно правилам, разработанным как для защиты данных, так и для повышения гибкости базы данных за счет устранения избыточности и несогласованных зависимостей.

**Зачем нужна нормализация?**
Цель нормализации — устранить избыточность данных и обеспечить их согласованность. Полностью нормализованная база данных позволяет расширять свою структуру для accommodate новых типов данных без значительного изменения существующей структуры. В результате приложения, взаимодействующие с базой данных, затрагиваются минимально.

**Нормальные формы (Normal forms)**
Нормальные формы — это серия руководящих принципов, обеспечивающих нормализацию базы данных. Обсудим некоторые основные нормальные формы:

*   **1NF (Первая нормальная форма):** Чтобы таблица была в первой нормальной форме, она должна следовать следующим правилам:
    *   Повторяющиеся группы не допускаются.
    *   Идентифицировать каждый набор связанных данных с помощью первичного ключа.
    *   Набор связанных данных должен иметь отдельную таблицу.
    *   Смешивание типов данных в одном столбце не допускается.
*   **2NF (Вторая нормальная форма):** Чтобы таблица была во второй нормальной форме, она должна следовать следующим правилам:
    *   Удовлетворять первой нормальной форме (1NF).
    *   Не должна иметь частичных зависимостей.
*   **3NF (Третья нормальная форма):** Чтобы таблица была в третьей нормальной форме, она должна следовать следующим правилам:
    *   Удовлетворять второй нормальной форме (2NF).
    *   Транзитивные функциональные зависимости не допускаются.
*   **BCNF (Нормальная форма Бойса-Кодда):** Нормальная форма Бойса-Кодда (BCNF) — это немного более строгая версия третьей нормальной формы (3NF), используемая для решения определенных типов аномалий, не решаемых исходно определенной 3NF. Иногда ее также называют нормальной формой 3.5 (3.5NF).
    *   Чтобы таблица была в нормальной форме Бойса-Кодда (BCNF), она должна следовать следующим правилам:
    *   Удовлетворять третьей нормальной форме (3NF).
    *   Для каждой функциональной зависимости X → Y, X должен быть суперключом.

Существуют и другие нормальные формы, такие как 4NF, 5NF и 6NF, но мы не будем их здесь обсуждать.

В реляционной базе данных отношение часто описывается как "нормализованное", если оно удовлетворяет третьей нормальной форме. Большинство отношений в 3NF свободны от аномалий вставки, обновления и удаления.

Как и в случае со многими формальными правилами и спецификациями, реальные сценарии не всегда позволяют достичь идеального соответствия. Если вы решите нарушить одно из первых трех правил нормализации, убедитесь, что ваше приложение anticipates любые проблемы, которые могут возникнуть, такие как избыточные данные и несогласованные зависимости.

**Преимущества**
Вот некоторые преимущества нормализации:
*   Уменьшает избыточность данных.
*   Улучшает дизайн данных.
*   Повышает согласованность данных.
*   Обеспечивает целостность ссылок (referential integrity).

**Недостатки**
Давайте посмотрим на некоторые недостатки нормализации:
*   Сложный дизайн данных.
*   Более медленная производительность.
*   Накладные расходы на обслуживание.
*   Требуется больше соединений (joins).

**Денормализация (Denormalization)**
Денормализация — это техника оптимизации базы данных, при которой мы добавляем избыточные данные в одну или несколько таблиц. Это может помочь нам избежать дорогостоящих соединений в реляционной базе данных. Она пытается улучшить производительность чтения за счет некоторого снижения производительности записи. Избыточные копии данных записываются в нескольких таблицах, чтобы избежать дорогостоящих соединений.

Когда данные становятся распределенными с использованием таких техник, как федерация и шардирование, управление соединениями по сети еще больше увеличивает сложность. Денормализация может обойти необходимость таких сложных соединений.

==*Примечание:* Денормализация не означает отмену нормализации.==

**Преимущества**
Давайте посмотрим на некоторые преимущества денормализации:
*   Получение данных происходит быстрее.
*   Написание запросов проще.
*   Уменьшение количества таблиц.
*   Удобство управления.

**Недостатки**
Ниже приведены некоторые недостатки денормализации:
*   Дорогостоящие вставки и обновления.
*   Увеличивает сложность проектирования базы данных.
*   Увеличивает избыточность данных.
*   Больше шансов на несогласованность данных.

---

### **Модели согласованности ACID и BASE** ###

Давайте обсудим модели согласованности ACID и BASE.

**ACID**
Термин ACID означает Атомарность (Atomicity), Согласованность (Consistency), Изолированность (Isolation) и Долговечность (Durability). Свойства ACID используются для поддержания целостности данных во время обработки транзакций.

Чтобы поддерживать согласованность до и после транзакции, реляционные базы данных следуют свойствам ACID. Давайте разберем эти термины:

*   **Атомарность (Atomic):** Все операции в транзакции выполняются успешно, или каждая операция откатывается.
*   **Согласованность (Consistent):** По завершении транзакции база данных структурно исправна.
*   **Изолированность (Isolated):** Транзакции не конфликтуют друг с другом. Конфликтующий доступ к данным moderated базой данных таким образом, что транзакции, кажется, выполняются последовательно.
*   **Долговечность (Durable):** После завершения транзакции и записи обновлений на диск, они останутся в системе даже в случае сбоя системы.

**BASE**
С увеличением объема данных и требований к высокой доступности подход к проектированию баз данных также dramatically изменился. Чтобы повысить способность к масштабированию и одновременно быть высокодоступными, мы перемещаем логику из базы данных на отдельные серверы. Таким образом, база данных становится более независимой и сосредоточенной на фактическом процессе хранения данных.

В мире NoSQL баз данных транзакции ACID менее распространены, поскольку некоторые базы данных ослабили требования к немедленной согласованности, актуальности данных и точности, чтобы получить другие преимущества, такие как масштабируемость и устойчивость.

Свойства BASE гораздо более свободны, чем гарантии ACID, но нет прямого однозначного соответствия между двумя моделями согласованности. Давайте разберем эти термины:

*   **Базовая доступность (Basic Availability):** База данных, по-видимому, работает большую часть времени.
*   **Неустойчивое состояние (Soft-state):** Хранилища не должны быть согласованными при записи, ни разные реплики должны быть взаимно согласованными все время.
*   **Конечная согласованность (Eventual consistency):** Данные могут быть несогласованными немедленно, но в конечном итоге они становятся согласованными. Чтения в системе все еще возможны, даже если они могут давать неправильный ответ из-за несогласованности.

**Компромиссы ACID vs BASE**
Нет правильного ответа на вопрос, нужна ли нашему приложению модель согласованности ACID или BASE. Обе модели были разработаны для удовлетворения различных требований. Выбирая базу данных, нам нужно помнить о свойствах обеих моделей и требованиях нашего приложения.

Учитывая свободную согласованность BASE, разработчикам нужно быть более осведомленными и строгими в отношении согласованных данных, если они выбирают хранилище BASE для своего приложения. Необходимо熟悉 с поведением BASE выбранной базы данных и работать в рамках этих ограничений.

С другой стороны, планирование с учетом ограничений BASE иногда может быть major недостатком по сравнению с простотой транзакций ACID. Полностью ACID база данных идеально подходит для случаев использования, где надежность и согласованность данных необходимы.

---

### **Теорема CAP (CAP Theorem)** ###

Теорема CAP утверждает, что распределенная система может обеспечить только две из трех желаемых характеристик: Согласованность (Consistency), Доступность (Availability) и Устойчивость к разделению (Partition tolerance) (CAP).

Давайте подробно рассмотрим три характеристики распределенных систем, к которым относится теорема CAP.

*   **Согласованность (Consistency):** Означает, что все клиенты видят одни и те же данные в одно и то же время, независимо от того, к какому узлу они подключаются. Для этого, когда данные записываются на один узел, они должны быть мгновенно перенаправлены или реплицированы на все узлы системы, прежде чем запись будет считаться "успешной".
*   **Доступность (Availability):** Означает, что любой клиент, делающий запрос на данные, получает ответ, даже если один или несколько узлов не работают.
*   **Устойчивость к разделению (Partition tolerance):** Означает, что система продолжает работать, несмотря на потерю сообщений или частичный сбой. Система, устойчивая к разделению, может выдержать любое количество сетевых сбоев, которые не приводят к отказу всей сети. Данные sufficiently реплицируются по комбинациям узлов и сетей, чтобы поддерживать работу системы во время временных простоев.

**Компромисс Согласованности-Доступности (Consistency-Availability Tradeoff)**
Мы живем в физическом мире и не можем гарантировать стабильность сети, поэтому распределенные базы данных должны выбирать Устойчивость к разделению (P). Это подразумевает компромисс между Согласованностью (C) и Доступностью (A).

*   **CA база данных:** CA база данных обеспечивает согласованность и доступность на всех узлах. Она не может этого сделать, если существует разделение (partition) между любыми двумя узлами в системе, и, следовательно, не может обеспечить отказоустойчивость.
    *   *Пример:* PostgreSQL, MariaDB.
*   **CP база данных:** CP база данных обеспечивает согласованность и устойчивость к разделению за счет доступности. Когда происходит разделение между любыми двумя узлами, система должна отключить несогласованный узел до разрешения раздела.
    *   *Пример:* MongoDB, Apache HBase.
*   **AP база данных:** AP база данных обеспечивает доступность и устойчивость к разделению за счет согласованности. Когда происходит разделение, все узлы остаются доступными, но те, которые находятся на неправильной стороне раздела, могут возвращать более старую версию данных, чем другие. Когда разделение разрешено, AP базы данных обычно повторно синхронизируют узлы, чтобы исправить все несогласованности в системе.
    *   *Пример:* Apache Cassandra, CouchDB.

---

### **Теорема PACELC (PACELC Theorem)** ###

Теорема PACELC является расширением теоремы CAP. Теорема CAP утверждает, что в случае сетевого разделения (P) в распределенной системе приходится выбирать между Доступностью (A) и Согласованностью (C).

PACELC расширяет теорему CAP, вводя задержку (L) как дополнительный атрибут распределенной системы. Теорема утверждает, что в остальное время (E), даже когда система работает нормально в отсутствие разделов, приходится выбирать между задержкой (L) и согласованностью (C).

Теорема PACELC была впервые описана Дэниелом Дж. Абади.

Теорема PACELC была разработана для решения ключевого ограничения теоремы CAP, поскольку она не предусматривает производительность или задержку.

Например, согласно теореме CAP, база данных может считаться доступной, если запрос возвращает ответ через 30 дней. Очевидно, что такая задержка была бы неприемлема для любого реального приложения.

---

### **Транзакции (Transactions)** ###

**Транзакция** — это серия операций с базой данных, которые считаются "единым блоком работы". Операции в транзакции либо все успешны, либо все неудачны. Таким образом, понятие транзакции поддерживает целостность данных при сбое части системы. Не все базы данных выбирают поддержку ACID транзакций, обычно потому, что они prioritising другие оптимизации, которые трудно или теоретически невозможно реализовать вместе.

Обычно реляционные базы данных поддерживают ACID транзакции, а нереляционные — нет (есть исключения).

**Состояния (States)**
Транзакция в базе данных может находиться в одном из следующих состояний:

*   **Активная (Active):** В этом состоянии транзакция выполняется. Это начальное состояние каждой транзакции.
*   **Частично зафиксированная (Partially Committed):** Когда транзакция выполняет свою последнюю операцию, она находится в состоянии частичной фиксации.
*   **Зафиксированная (Committed):** Если транзакция успешно выполняет все свои операции, она считается зафиксированной. Все ее эффекты теперь permanently установлены в системе базы данных.
*   **Неудачная (Failed):** Говорят, что транзакция находится в неудачном состоянии, если какая-либо из проверок, выполненных системой восстановления базы данных, не удается. Неудачная транзакция не может продолжаться дальше.
*   **Прерванная (Aborted):** Если какая-либо из проверок не удается и транзакция достигла неудачного состояния, то диспетчер восстановления откатывает все ее операции записи в базе данных, чтобы вернуть базу данных в исходное состояние, в котором она была до выполнения транзакции. Транзакции в этом состоянии прерываются.
    Модуль восстановления базы данных может выбрать одну из двух операций после прерывания транзакции:
    *   Перезапустить транзакцию
    *   Завершить транзакцию
*   **Завершенная (Terminated):** Если отката нет или транзакция переходит из состояния "зафиксирована", то система согласована и готова для новой транзакции, а старая транзакция завершена.

---

### **Распределенные транзакции (Distributed Transactions)** ###

**Распределенная транзакция** — это набор операций с данными, которые выполняются в двух или более базах данных. Обычно она координируется между отдельными узлами, соединенными сетью, но также может охватывать несколько баз данных на одном сервере.

**Зачем нужны распределенные транзакции?**
В отличие от ACID транзакции в одной базе данных, распределенная транзакция involves изменение данных в нескольких базах данных. Следовательно, обработка распределенных транзакций более сложна, потому что база данных должна координировать фиксацию или откат изменений в транзакции как самостоятельной единицы.

Другими словами, все узлы должны зафиксировать изменения, или все должны прервать, и вся транзакция откатывается. Вот почему нам нужны распределенные транзакции.

Теперь давайте рассмотрим некоторые популярные решения для распределенных транзакций:

**Двухфазная фиксация (Two-Phase commit)**
Протокол двухфазной фиксации (2PC) — это распределенный алгоритм, который координирует все процессы, участвующие в распределенной транзакции, относительно того, следует ли фиксировать или прерывать (откатывать) транзакцию.

Этот протокол достигает своей цели даже во многих случаях временных сбоев системы и поэтому широко используется. Однако он не устойчив ко всем возможным конфигурациям сбоев, и в редких случаях требуется ручное вмешательство для исправления результата.

Этот протокол требует наличия узла-координатора, который basically координирует и oversees транзакцию на разных узлах. Координатор пытается достичь консенсуса среди набора процессов в две фазы, отсюда и название.

*   *Фазы:*
    1.  **Фаза подготовки (Prepare phase):** Фаза подготовки включает, что узел-координатор собирает консенсус от каждого из узлов-участников. Транзакция будет прервана, если каждый из узлов не ответит, что он "готов".
    2.  **Фаза фиксации (Commit phase):** Если все участники отвечают координатору, что они готовы, то координатор просит все узлы зафиксировать транзакцию. Если происходит сбой, транзакция будет откатана.
*   *Проблемы:*
    *   Что, если один из узлов выйдет из строя?
    *   Что, если сам координатор выйдет из строя?
    *   Это блокирующий протокол.

**Трехфазная фиксация (Three-Phase commit)**
Трехфазная фиксация (3PC) — это расширение двухфазной фиксации, где фаза фиксации разделена на две фазы. Это помогает решить проблему блокировки, которая возникает в протоколе двухфазной фиксации.

*   *Фазы:*
    1.  **Фаза подготовки (Prepare phase):** Эта фаза такая же, как и в двухфазной фиксации.
    2.  **Фаза предварительной фиксации (Pre-commit phase):** Координатор выдает сообщение предварительной фиксации, и все участвующие узлы должны подтвердить его. Если участник не получает это сообщение вовремя, транзакция прерывается.
    3.  **Фаза фиксации (Commit phase):** Этот шаг также похож на протокол двухфазной фиксации.
*   *Чем полезна фаза предварительной фиксации?*
    Фаза предварительной фиксации accomplishes следующее:
    *   Если узлы-участники находятся в этой фазе, это означает, что каждый участник завершил первую фазу. Завершение фазы подготовки гарантировано.
    *   Каждая фаза теперь может иметь тайм-аут и избегать неопределенного ожидания.

**Саги (Sagas)**
**Сага** — это последовательность локальных транзакций. Каждая локальная транзакция обновляет базу данных и публикует сообщение или событие для запуска следующей локальной транзакции в саге. Если локальная транзакция не выполняется, потому что она нарушает бизнес-правило, то сага выполняет серию компенсирующих транзакций, которые отменяют изменения, сделанные предыдущими локальными транзакциями.

*   *Координация (Coordination):*
    Существует два распространенных подхода к реализации:
    *   **Хореография (Choreography):** Каждая локальная транзакция публикует доменные события, которые запускают локальные транзакции в других сервисах.
    *   **Оркестрация (Orchestration):** Оркестратор указывает участникам, какие локальные транзакции выполнять.
*   *Проблемы:*
    *   Шаблон Saga особенно сложно отлаживать.
    *   Существует риск циклической зависимости между участниками саги.
    *   Отсутствие изоляции данных участников накладывает проблемы долговечности.
    *   Тестирование затруднено, потому что все службы должны работать для имитации транзакции.

---

### **Шардирование (Sharding)** ###

Прежде чем обсуждать шардирование, давайте поговорим о разделении данных:

**Разделение данных (Data Partitioning)**
**Разделение данных** — это метод разбиения базы данных на множество более мелких частей. Это процесс разделения базы данных или таблицы на несколько машин для повышения управляемости, производительности и доступности базы данных.

**Методы**
Существует много различных способов, которые можно использовать, чтобы решить, как разбить базу данных приложения на несколько меньших БД. Ниже приведены два наиболее популярных метода, используемых различными крупномасштабными приложениями:

*   **Горизонтальное разделение (Horizontal Partitioning) (или Шардирование):** В этой стратегии мы разбиваем данные таблицы горизонтально на основе диапазона значений, определяемого ключом разделения. Это также называется шардированием базы данных.
*   **Вертикальное разделение (Vertical Partitioning):** При вертикальном разделении мы разделяем данные вертикально по столбцам. Мы делим таблицы на относительно меньшие таблицы с небольшим количеством элементов, и каждая часть присутствует в отдельном разделении.

В этом руководстве мы specifically сосредоточимся на шардировании.

**Что такое шардирование?**
**Шардирование** — это архитектурный шаблон базы данных, связанный с горизонтальным разделением, который заключается в разделении строк одной таблицы на несколько разных таблиц, известных как разделы или шарды. Каждый раздел имеет одинаковую схему и столбцы, но также подмножество общих данных. Точно так же данные, хранящиеся в каждом из них, уникальны и независимы от данных, хранящихся в других разделах.

Обоснование шардирования данных заключается в том, что после определенного момента дешевле и целесообразнее масштабироваться горизонтально, добавляя больше машин, чем масштабировать его вертикально, добавляя мощные серверы. Шардирование может быть реализовано как на уровне приложения, так и на уровне базы данных.

**Критерии разделения**
Существует большое количество критериев, доступных для разделения данных. Некоторые наиболее часто используемые критерии:

*   **На основе хэша (Hash-Based):** Эта стратегия делит строки на разные разделы на основе алгоритма хеширования, а не группирует строки базы данных на основе непрерывных индексов.
    *   Недостаток этого метода в том, что динамическое добавление/удаление серверов баз данных становится дорогостоящим.
*   **На основе списка (List-Based):** При разделении на основе списка каждый раздел определяется и выбирается на основе списка значений в столбце, а не набора непрерывных диапазонов значений.
*   **На основе диапазона (Range Based):** Разделение по диапазону отображает данные в различные разделы на основе диапазонов значений ключа разделения. Другими словами, мы разделяем таблицу таким образом, что каждый раздел содержит строки в пределах заданного диапазона, определенного ключом разделения.
    *   Диапазоны должны быть непрерывными, но не перекрывающимися, где каждый диапазон specifies невключительную нижнюю и верхнюю границу для раздела. Любые значения ключа разделения, равные или превышающие верхнюю границу диапазона, добавляются в следующий раздел.
*   **Композитное (Composite):** Как следует из названия, композитное разделение разделяет данные на основе двух или более методов разделения. Здесь мы сначала разделяем данные с помощью одного метода, а затем каждый раздел further подразделяется на подразделы с использованием того же или другого метода.

**Преимущества**
Но зачем нам нужно шардирование? Вот некоторые преимущества:
*   **Доступность:** Обеспечивает логическую независимость разделенной базы данных, гарантируя высокую доступность нашего приложения. Здесь отдельными разделами можно управлять независимо.
*   **Масштабируемость:** Доказывает увеличение масштабируемости за счет распределения данных по нескольким разделам.
*   **Безопасность:** Помогает повысить безопасность системы за счет хранения конфиденциальных и неконфиденциальных данных в разных разделах. Это может обеспечить лучшую управляемость и безопасность конфиденциальных данных.
*   **Производительность запросов:** Улучшает производительность системы. Вместо запроса ко всей базе данных теперь системе нужно запрашивать только меньший раздел.
*   **Управляемость данных:** Делит таблицы и индексы на более мелкие и управляемые единицы.

**Недостатки**
*   **Сложность:** Шардирование увеличивает сложность системы в целом.
*   **Соединения между шардами (Joins across shards):** После того как база данных разделена и разбросана по нескольким машинам, часто нецелесообразно выполнять соединения, охватывающие несколько шардов базы данных. Такие соединения не будут эффективными по производительности, поскольку данные должны быть извлечены с нескольких серверов.
*   **Ребалансировка (Rebalancing):** Если распределение данных неравномерное или есть большая нагрузка на один шард, в таких случаях нам приходится перебалансировать наши шарды, чтобы запросы распределялись как можно более равномерно.

**Когда использовать шардирование?**
Вот некоторые причины, по которым шардирование может быть правильным выбором:
*   Использование существующего оборудования вместо высокопроизводительных машин.
*   Хранение данных в отдельных географических регионах.
*   Быстрое масштабирование путем добавления большего количества шардов.
*   Лучшая производительность, так как каждая машина менее нагружена.
*   Когда требуется больше одновременных подключений.

---

### **Консистентное хеширование (Consistent Hashing)** ###

Давайте сначала поймем проблему, которую мы пытаемся решить.

**Зачем это нужно?**
В традиционных методах распределения на основе хеширования мы используем хеш-функцию для хеширования наших ключей разделения (т.е. ID запроса или IP). Затем, если мы используем modulo от общего количества узлов (серверов или баз данных). Это даст нам узел, на который мы хотим направить наш запрос.

Проблема с этим подходом в том, что если мы добавляем или удаляем узел, это вызовет изменение N, что означает, что наша стратегия mapping нарушится, так как те же запросы теперь будут mapping на другой сервер. Как следствие, большинство запросов потребуют перераспределения, что очень неэффективно.

Мы хотим равномерно распределять запросы между разными узлами так, чтобы мы могли добавлять или удалять узлы с минимальными усилиями. Следовательно, нам нужна схема распределения, которая не зависит напрямую от количества узлов (или серверов), так чтобы при добавлении или удалении узлов количество ключей, которые необходимо переместить, было минимальным.

Консистентное хеширование решает эту проблему горизонтальной масштабируемости, гарантируя, что каждый раз, когда мы масштабируемся вверх или вниз, нам не приходится переупорядочивать все ключи или затрагивать все серверы.

Теперь, когда мы понимаем проблему, давайте обсудим консистентное хеширование подробно.

**Как это работает**
Консистентное хеширование — это распределенная схема хеширования, которая работает независимо от количества узлов в распределенной хеш-таблице, назначая им позицию на абстрактном круге или хеш-кольце. Это позволяет серверам и объектам масштабироваться без влияния на всю систему.

Используя консистентное хеширование, только K/N данных потребуют перераспределения.
`R = K / N`
Где:
*   R: Данные, которые потребуют перераспределения.
*   K: Количество ключей разделения.
*   N: Количество узлов.

Выходные данные хеш-функции — это диапазон, скажем, 0...m-1, который мы можем представить на нашем хеш-кольце. Мы хешируем запросы и распределяем их по кольцу в зависимости от того, каким был вывод. Точно так же мы также хешируем узел и распределяем их по тому же кольцу.

Теперь, когда поступает запрос, мы можем просто направить его к ближайшему узлу по часовой стрелке (может быть и против часовой стрелки). Это означает, что если узел добавляется или удаляется, мы можем использовать ближайший узел, и только часть запросов needs to be перемаршрутизирована.

В теории консистентное хеширование должно распределять нагрузку равномерно, однако на практике это не так. Обычно распределение нагрузки неравномерно, и один сервер может в конечном итоге обрабатывать большинство запросов, становясь "горячей точкой" (hotspot), essentially узким местом для системы. Мы можем исправить это, добавив дополнительные узлы, но это может быть дорого.

Давайте посмотрим, как мы можем решить эти проблемы.

**Виртуальные узлы (Virtual Nodes)**
Чтобы обеспечить более равномерное распределение нагрузки, мы можем ввести понятие виртуального узла, иногда также называемого VNode.

Вместо назначения одной позиции узлу, диапазон хешей делится на несколько меньших диапазонов, и каждому физическому узлу назначается несколько из этих меньших диапазонов. Каждый из этих поддиапазонов считается VNode. Следовательно, виртуальные узлы — это basically существующие физические узлы, отображенные несколько раз по хеш-кольцу, чтобы минимизировать изменения диапазона, назначенного узлу.

Для этого мы можем использовать k количество хеш-функций.

Поскольку VNodes помогают более равномерно распределять нагрузку по физическим узлам в кластере, разделяя диапазоны хешей на меньшие поддиапазоны, это ускоряет процесс ребалансировки после добавления или удаления узлов. Это также помогает нам снизить вероятность возникновения горячих точек.

**Репликация данных (Data Replication)**
Чтобы обеспечить высокую доступность и долговечность, консистентное хеширование реплицирует каждый элемент данных на нескольких N узлах в системе, где значение N эквивалентно коэффициенту репликации (replication factor).

Коэффициент репликации — это количество узлов, которые будут получать копию одних и тех же данных. В eventually consistent системах это делается асинхронно.

**Преимущества**
Давайте посмотрим на некоторые преимущества консистентного хеширования:
*   Делает быстрое масштабирование вверх и вниз более предсказуемым.
*   Облегчает разделение и репликацию между узлами.
*   Обеспечивает масштабируемость и доступность.
*   Уменьшает количество горячих точек.

**Недостатки**
Ниже приведены некоторые недостатки консистентного хеширования:
*   Увеличивает сложность.
*   Каскадные сбои (Cascading failures).
*   Распределение нагрузки все еще может быть неравномерным.
*   Управление ключами может быть дорогостоящим при временных сбоях узлов.

**Примеры**
Давайте рассмотрим некоторые примеры, где используется консистентное хеширование:
*   Разделение данных в Apache Cassandra.
*   Распределение нагрузки по нескольким хостам хранения в Amazon DynamoDB.

---

### **Федерация баз данных (Database Federation)** ###

**Федерация** (или функциональное разделение) разделяет базы данных по функциям. Архитектура федерации позволяет нескольким отдельным физическим базам данных выглядеть как одна логическая база данных для конечных пользователей.

Все компоненты федерации связаны между собой одной или несколькими **федеральными схемами**, которые выражают общность данных во всей федерации. Эти федеральные схемы используются для определения информации, которой могут обмениваться компоненты федерации, и для обеспечения общей основы для взаимодействия между ними.

Федерация также предоставляет целостное, унифицированное представление данных, полученных из нескольких источников. Источники данных для федеративных систем могут включать базы данных и различные другие формы структурированных и неструктурированных данных.

---

#### **Характеристики** ###

Рассмотрим ключевые характеристики федеративной базы данных:

*   **Прозрачность (Transparency):** Федеративная база данных скрывает от пользователей различия и особенности реализации лежащих в основе источников данных. Следовательно, пользователям не нужно знать, где хранятся данные.
*   **Гетерогенность (Heterogeneity):** Источники данных могут различаться множеством способов. Федеративная система баз данных может работать с различным оборудованием, сетевыми протоколами, моделями данных и т.д.
*   **Расширяемость (Extensibility):** Для удовлетворения меняющихся потребностей бизнеса могут потребоваться новые источники. Хорошая федеративная система баз данных должна упрощать добавление новых источников.
*   **Автономность (Autonomy):** Федеративная база данных не изменяет существующие источники данных, их интерфейсы должны оставаться прежними.
*   **Интеграция данных (Data integration):** Федеративная база данных может интегрировать данные из различных протоколов, систем управления базами данных и т.д.

---

#### **Преимущества** ###

Вот преимущества федеративных баз данных:

*   Гибкий обмен данными.
*   Автономность компонентов базы данных.
*   Доступ к разнородным данным унифицированным способом.
*   Отсутствие тесной связи приложений с унаследованными базами данных.

---

#### **Недостатки** ###

Ниже приведены недостатки федеративных баз данных:

*   Добавляет больше оборудования и дополнительную сложность.
*   Объединение данных из двух баз данных является сложным.
*   Зависимость от автономных источников данных.
*   Производительность запросов и масштабируемость.