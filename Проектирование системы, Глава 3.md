### **N-звенная архитектура (N-tier architecture)**

  

N-звенная архитектура делит приложение на логические уровни (layers) и физические звенья (tiers). Уровни — это способ разделения ответственности и управления зависимостями. Каждый уровень имеет определенную ответственность. Вышележащий уровень может использовать сервисы нижележащего уровня, но не наоборот.

  

**Звенья** физически разделены и работают на разных машинах. Звено может обращаться к другому звену напрямую или использовать асинхронную передачу сообщений. Хотя каждый уровень может размещаться в собственном звене, это не обязательно. Несколько уровней могут размещаться на одном и том же звене. Физическое разделение звеньев улучшает масштабируемость и отказоустойчивость, но добавляет задержку из-за дополнительного сетевого взаимодействия.

  

##### N-звенная архитектура может быть двух типов:

*   **В архитектуре с закрытыми уровнями (closed layer)** уровень может вызывать только следующий, непосредственно нижележащий уровень.

*   **В архитектуре с открытыми уровнями (open layer)** уровень может вызывать любой из нижележащих уровней.

  

Архитектура с закрытыми уровнями ограничивает зависимости между уровнями. Однако она может создавать ненужный сетевой трафик, если один уровень просто передает запросы следующему уровню.

  

##### **Типы N-звенных архитектур**

Рассмотрим некоторые примеры N-звенной архитектуры:

* **Двухзвенная архитектура (2-Tier)**

  В этой архитектуре уровень представления работает на клиенте и взаимодействует с хранилищем данных. Отсутствует уровень бизнес-логики или промежуточное звено между клиентом и сервером.

  

* **Трехзвенная архитектура (3-Tier)**

  Трехзвенная архитектура широко используется и состоит из следующих различных уровней:

  *   **Уровень представления (Presentation layer):** Обрабатывает взаимодействие пользователя с приложением.

  *   **Уровень бизнес-логики (Business Logic layer):** Принимает данные от уровня приложения, проверяет их в соответствии с бизнес-логикой и передает на уровень данных.

  *   **Уровень доступа к данным (Data Access layer):** Получает данные от бизнес-уровня и выполняет необходимые операции с базой данных.

  

* **Однозвенная архитектура (Single Tier или 1-Tier)**

  Это самая простая архитектура, эквивалентная запуску приложения на персональном компьютере. Все необходимые компоненты для работы приложения находятся в одном приложении или на одном сервере.

  

##### **Преимущества и недостатки**

**Преимущества:**

*   Может повысить доступность.

*   Лучшая безопасность, так как уровни могут действовать как брандмауэр.

*   Раздельные звенья позволяют масштабировать их по мере необходимости.

*   Упрощается обслуживание, так как разные люди могут управлять разными звеньями.

  

**Недостатки:**

  

*   Повышенная сложность системы в целом.

*   Увеличение сетевой задержки с ростом количества звеньев.

*   Дороговизна, так как каждое звено имеет свою собственную стоимость оборудования.

*   Сложность управления сетевой безопасностью.

  

---

  

### **Брокеры сообщений (Message Brokers)**

  

**Брокер сообщений** — это программное обеспечение, которое позволяет приложениям, системам и сервисам общаться друг с другом и обмениваться информацией. Брокер сообщений делает это, преобразуя сообщения между формальными протоколами обмена сообщениями. Это позволяет взаимозависимым сервисам «общаться» напрямую, даже если они были написаны на разных языках или реализованы на разных платформах.

  

Брокеры сообщений могут проверять, хранить, маршрутизировать и доставлять сообщения по соответствующим назначениям. Они служат посредниками между другими приложениями, позволяя отправителям выдавать сообщения, не зная, где находятся получатели, активны ли они или сколько их. Это способствует разделению процессов и сервисов внутри систем.

  

##### **Модели**

  

Брокеры сообщений предлагают два основных шаблона распределения сообщений или стиля обмена сообщениями:

  

*   **Точка-точка (Point-to-Point messaging):** Это шаблон распределения, используемый в очередях сообщений с отношением «один к одному» между отправителем и получателем сообщения.

*   **Издатель-Подписчик (Publish-Subscribe messaging):** В этом шаблоне распределения сообщений, часто называемом «pub/sub», производитель каждого сообщения публикует его в тему (topic), а несколько потребителей сообщений подписываются на темы, из которых они хотят получать сообщения.

  

##### **Сравнительный анализ**

  

**Брокеры сообщений против Потоковой обработки событий (Event streaming)**

  

*   **Брокеры сообщений** могут поддерживать два или более шаблонов обмена сообщениями, включая очереди сообщений и pub/sub.

*   **Платформы потоковой обработки событий** предлагают только шаблоны распределения в стиле pub/sub. Они предназначены для работы с большими объемами сообщений и легко масштабируются. Они способны упорядочивать потоки записей по категориям, называемым темами (topics), и хранить их в течение заданного времени. В отличие от брокеров сообщений, платформы потоковой обработки событий не могут гарантировать доставку сообщений или отслеживать, какие потребители получили сообщения.

  

Платформы потоковой обработки событий предлагают большую масштабируемость, чем брокеры сообщений, но меньше функций, обеспечивающих отказоустойчивость (например, повторная отправка сообщений), а также более ограниченные возможности маршрутизации и организации очередей сообщений.

  

**Брокеры сообщений против Сервисной шины предприятия (ESB)**

  

*   **Инфраструктура Сервисной шины предприятия (ESB)** сложна, ее может быть трудно интегрировать и дорого поддерживать. Трудно устранять неполадки, когда проблемы возникают в производственных средах, их нелегко масштабировать, а обновление утомительно.

  

*   **Брокеры сообщений** являются «легковесной» альтернативой ESB, предоставляющей аналогичную функциональность, механизм для межсервисного взаимодействия, по более низкой стоимости. Они хорошо подходят для использования в архитектурах микросервисов, которые стали более распространенными, поскольку ESB вышли из моды.

  

##### **Примеры**

  

Вот некоторые часто используемые брокеры сообщений:

*   NATS

*   Apache Kafka

*   RabbitMQ

*   ActiveMQ

  

---

  

### **Очереди сообщений (Message Queues)**

  

**Очередь сообщений** — это форма сервис-сервисного взаимодействия, которая обеспечивает асинхронную связь. Она асинхронно получает сообщения от производителей (producers) и отправляет их потребителям (consumers).

  

Очереди используются для эффективного управления запросами в крупномасштабных распределенных системах. В небольших системах с минимальными нагрузками на обработку и небольшими базами данных операции записи могут быть предсказуемо быстрыми. Однако в более сложных и крупных системах операции записи могут занимать почти неопределенное количество времени.

  

##### **Принцип работы**

  

Сообщения хранятся в очереди до тех пор, пока они не будут обработаны и удалены. Каждое сообщение обрабатывается только один раз одним потребителем. Вот как это работает:

  

1.  Производитель публикует задание в очередь, а затем уведомляет пользователя о статусе задания.

2.  Потребитель забирает задание из очереди, обрабатывает его, а затем сигнализирует, что задание завершено.

  

##### **Преимущества**

  

Обсудим некоторые преимущества использования очереди сообщений:

  

*   **Масштабируемость:** Очереди сообщений позволяют масштабироваться именно там, где это необходимо. Когда рабочие нагрузки достигают пика, несколько экземпляров нашего приложения могут добавлять все запросы в очередь без риска коллизий.

*   **Разделение (Decoupling):** Очереди сообщений устраняют зависимости между компонентами и значительно упрощают реализацию несвязанных приложений.

*   **Производительность:** Очереди сообщений обеспечивают асинхронную связь, что означает, что конечные точки, которые производят и потребляют сообщения, взаимодействуют с очередью, а не друг с другом. Производители могут добавлять запросы в очередь, не дожидаясь их обработки.

*   **Надежность:** Очереди делают наши данные устойчивыми (persistent) и уменьшают количество ошибок, которые происходят, когда различные части нашей системы отключаются.

  

##### **Функции**

  

Теперь давайте обсудим некоторые желаемые функции очередей сообщений:

  

*   **Доставка по Push или Pull:** Большинство очередей сообщений предоставляют как push, так и pull варианты для получения сообщений. Pull означает непрерывный опрос очереди на наличие новых сообщений. Push означает, что потребитель уведомляется, когда сообщение доступно.

*   **Очереди FIFO (First-In-First-Out):** В этих очередях самая старая (или первая) запись, иногда называемая «головой» очереди, обрабатывается первой.

*   **Планирование или Отложенная доставка:** Многие очереди сообщений поддерживают установку конкретного времени доставки для сообщения.

*   **Доставка Как Минимум Один Раз (At-Least-Once Delivery):** Очереди сообщений могут хранить несколько копий сообщений для избыточности и высокой доступности и повторно отправлять сообщения в случае сбоев связи или ошибок, чтобы обеспечить их доставку как минимум один раз.

*   **Доставка Ровно Один Раз (Exactly-Once Delivery):** Когда дубликаты недопустимы, очереди сообщений FIFO гарантируют, что каждое сообщение доставляется ровно один раз (и только один раз), автоматически отфильтровывая дубликаты.

*   **Очереди Мертвых Писем (Dead-letter Queues):** Очередь мертвых писем — это очередь, в которую другие очереди могут отправлять сообщения, которые не могут быть успешно обработаны.

*   **Упорядочивание:** Большинство очередей сообщений обеспечивают упорядочивание по наилучшему усилию (best-effort ordering), которое гарантирует, что сообщения обычно доставляются в том же порядке, в каком они были отправлены, и что сообщение доставляется по крайней мере один раз.

*   **Сообщения-«Ядовитые таблетки» (Poison-pill Messages):** «Ядовитые таблетки» — это специальные сообщения, которые могут быть получены, но не обработаны. Это механизм, используемый для сигнала потребителю о завершении его работы.

*   **Безопасность:** Очереди сообщений будут аутентифицировать приложения, которые пытаются получить доступ к очереди, это позволяет нам шифровать сообщения в сети, а также в самой очереди.

*   **Очереди Заданий (Task Queues):** Очереди заданий получают задачи и связанные с ними данные, запускают их, а затем доставляют их результаты.

*   **Противодавление (Backpressure):** Если очереди начинают значительно расти, размер очереди может стать больше, чем память, что приведет к промахам кэша, чтению с диска и еще более медленной производительности. Противодавление может помочь, ограничивая размер очереди.

  

##### **Примеры**

  

Широко используемые очереди сообщений:

*   Amazon SQS

*   RabbitMQ

*   ActiveMQ

*   ZeroMQ

  

---

  

### **Паттерн «Издатель-Подписчик» (Publish-Subscribe)**

  

Подобно очереди сообщений, publish-subscribe также является формой сервис-сервисного взаимодействия, которая обеспечивает асинхронную связь. В модели pub/sub любое сообщение, опубликованное в тему, немедленно передается всем подписчикам этой темы.

  

Подписчики на тему сообщения часто выполняют разные функции и могут параллельно делать что-то разное с сообщением. Издателю не нужно знать, кто использует информацию, которую он транслирует, а подписчикам не нужно знать, откуда пришло сообщение. Этот стиль обмена сообщениями немного отличается от очередей сообщений, где компонент, отправляющий сообщение, часто знает место назначения, в которое он отправляет.

  

##### **Принцип работы**

  

В отличие от очередей сообщений, которые группируют сообщения до их получения, темы сообщений передают сообщения с минимальной очередью или без нее и немедленно передают их всем подписчикам. Вот как это работает:

  

1.  Тема сообщения предоставляет легковесный механизм для широковещательных асинхронных уведомлений о событиях.

2.  Чтобы транслировать сообщение, компонент, называемый издателем (publisher), просто помещает сообщение в тему.

3.  Все компоненты, которые подписаны на тему (известные как подписчики, subscribers), получат каждое сообщение, которое было передано.

  

##### **Преимущества**

  

Обсудим некоторые преимущества использования publish-subscribe:

*   **Устранение опроса (Polling):** Темы сообщений позволяют осуществлять мгновенную доставку на основе push-уведомлений, устраняя необходимость для потребителей сообщений периодически проверять или «опрашивать» наличие новой информации.

*   **Динамическое нацеливание:** Pub/Sub упрощает обнаружение сервисов. Вместо того чтобы вести список узлов, куда приложение может отправлять сообщения, издатель просто публикует сообщения в тему. Затем любая заинтересованная сторона подпишет свою конечную точку на тему и начнет получать эти сообщения.

*   **Разделение и Независимое Масштабирование:** Издатели и подписчики разделены и работают независимо друг от друга, что позволяет нам разрабатывать и масштабировать их независимо.

*   **Упрощение связи:** Модель «Издатель-Подписчик» снижает сложность, заменяя все point-to-point соединения одним подключением к теме сообщений.

  

##### **Функции**

  

Теперь давайте обсудим некоторые желаемые функции publish-subscribe:

  

*   **Push-доставка:** Pub/Sub мгновенно передает асинхронные уведомления о событиях, когда сообщения публикуются в теме.

*   **Несколько протоколов доставки:** В модели «Издатель-Подписчик» темы обычно могут подключаться к нескольким типам конечных точек.

*   **Фанаут (Fanout):** Этот сценарий происходит, когда сообщение отправляется в тему, а затем реплицируется и передается в несколько конечных точек.

*   **Фильтрация:** Эта функция позволяет подписчику создать политику фильтрации сообщений.

*   **Долговечность (Durability):** Службы обмена сообщениями Pub/Sub часто обеспечивают очень высокую долговечность.

*   **Безопасность:** Темы сообщений аутентифицируют приложения, которые пытаются публиковать контент.

  

##### **Примеры**

  

Вот некоторые часто используемые технологии publish-subscribe:

*   Amazon SNS

*   Google Pub/Sub

  

---

  

### **Сервисная шина предприятия (Enterprise Service Bus - ESB)**

  

**Сервисная шина предприятия (ESB)** — это архитектурный шаблон, в котором централизованный программный компонент выполняет интеграции между приложениями. Он выполняет преобразования моделей данных, обрабатывает подключение, выполняет маршрутизацию сообщений, преобразует протоколы связи и потенциально управляет композицией нескольких запросов. ESB может сделать эти интеграции и преобразования доступными в виде сервисного интерфейса для повторного использования новыми приложениями.

  

##### **Преимущества и недостатки**

  

**Преимущества:**

  

*   Повышение производительности разработчиков.

*   Более простое и рентабельное масштабирование.

*   Большая отказоустойчивость.

  

**Недостатки:**

  

*   Внесение изменений или улучшений в одну интеграцию может дестабилизировать других, кто использует эту же интеграцию.

*   Единая точка отказа может нарушить всю связь.

*   Высокая сложность конфигурации и обслуживания.

*   ESB управляется централизованно, что затрудняет межкомандное сотрудничество.

  

##### **Примеры**

  

Широко используемые технологии ESB:

*   Azure Service Bus

*   IBM App Connect

*   Apache Camel

*   Fuse ESB

  

---

  

### **Монолиты и Микросервисы (Monoliths and Microservices)**

  

**Монолит** — это самодостаточное и независимое приложение. Он строится как единый блок и отвечает не только за конкретную задачу, но может выполнять каждый шаг, необходимый для удовлетворения бизнес-потребности.

  

**Преимущества:**

  

*   Простота разработки и отладки.

*   Быстрая и надежная связь.

*   Легкий мониторинг и тестирование.

*   Поддерживает ACID-транзакции.

  

**Недостатки:**

  

*   Обслуживание усложняется с ростом кодовой базы.

*   Тесно связанное приложение, трудно расширять.

*   Требует приверженности определенному технологическому стеку.

*   При каждом обновлении все приложение переразвертывается.

*   Сниженная надежность.

  

**Модульные монолиты (Modular Monoliths)**

  

**Модульный монолит** — это подход, при котором мы создаем и развертываем одно приложение (это монолитная часть), но мы строим его таким образом, что разбиваем код на независимые модули для каждой функции, необходимой в нашем приложении.

  

**Микросервисы (Microservices)**

  

**Архитектура микросервисов** состоит из набора небольших, автономных сервисов, где каждый сервис является самодостаточным и должен реализовывать одну бизнес-возможность в ограниченном контексте (bounded context).

  

Каждый сервис имеет отдельную кодовую базу. Сервисы могут развертываться независимо. Сервисы несут ответственность за сохранение своих собственных данных.

  

##### **Характеристики**

  

Стиль архитектуры микросервисов имеет следующие характеристики:

  

*   **Слабая связанность (Loosely coupled):** Сервисы должны быть слабо связаны.

*   **Небольшие и сфокусированные:** Речь идет об области и ответственности, а не о размере.

*   **Построены для бизнеса.**

*   **Устойчивость и отказоустойчивость.**

*   **Высокая сопровождаемость.**

  

##### **Преимущества и недостатки**

  

**Преимущества:**

  

*   Слабо связанные сервисы.

*   Сервисы могут развертываться независимо.

*   Улучшенная отказоустойчивость и изоляция данных.

*   Лучшая масштабируемость.

*   Устраняет долгосрочные обязательства перед конкретным технологическим стеком.

  

**Недостатки:**

  

*   Сложность распределенной системы.

*   Тестирование более затруднено.

*   Дорогое обслуживание.

*   Проблемы целостности и согласованности данных.

*   Сетевые заторы и задержки.

  

##### **Распределенный монолит (Distributed Monolith)**

  

**Распределенный монолит** — это система, которая напоминает архитектуру микросервисов, но тесно связана внутри себя, как монолитное приложение.

  

Наши микросервисы — это просто распределенный монолит, если применимо любое из следующего:

  

*   Требуется связь с низкой задержкой.

*   Сервисы не масштабируются легко.

*   Зависимость между сервисами.

*   Совместное использование одних и тех же ресурсов, таких как базы данных.

*   Тесно связанные системы.

  

##### **Почему вам не нужны микросервисы**

  

Микросервисы не являются серебряной пулей. Они решают организационную проблему. Рекомендуется начинать с монолита при создании новой системы.

  

Прежде чем принять решение о переходе на архитектуру микросервисов, нужно задать себе вопросы:

  

*   «Слишком ли велика команда для эффективной работы над общей кодовой базой?»

*   «Ограничивают ли команды другие команды?»

*   «Приносят ли микросервисы явную бизнес-ценность для нас?»

*   «Достаточно ли зрел наш бизнес для использования микросервисов?»

  

Если вашему приложению не требуется разбивать на микросервисы, они вам не нужны.

  

---

  

### **Событийно-ориентированная архитектура (Event-Driven Architecture - EDA)**

  

**Событийно-ориентированная архитектура (EDA)** — это способ использования событий для общения внутри системы. Как правило, используется брокер сообщений для асинхронной публикации и потребления событий. Издатель не знает, кто потребляет событие, а потребители не знают друг о друге. EDA — это просто способ достижения слабой связи между сервисами в системе.

  

**Что такое событие?**

  

**Событие** — это точка данных, которая представляет изменения состояния в системе.

  

**Компоненты:**

  

Архитектуры, управляемые событиями, имеют три ключевых компонента:

  

1.  **Производители событий (Event producers):** Публикуют событие в маршрутизатор.

2.  **Маршрутизаторы событий (Event routers):** Фильтруют и передают события потребителям.

3.  **Потребители событий (Event consumers):** Используют события для отражения изменений в системе.

  

==*Примечание: Точки на диаграмме представляют различные события в системе.*==

  

##### **Паттерны**

  

Существует несколько способов реализации EDA:

  

*   Саги (Sagas)

*   Издатель-Подписчик (Publish-Subscribe)

*   Перенос событий (Event Sourcing)

*   Разделение ответственности команд и запросов (CQRS)

  

##### **Преимущества, недостатки и примеры**

  

**Преимущества:**

  

*   Разделенные производители и потребители.

*   Высокая масштабируемость и распределенность.

*   Легко добавлять новых потребителей.

*   Повышает гибкость.

  

**Проблемы:**

  

*   Гарантированная доставка.

*   Обработка ошибок затруднена.

*   Обработка событий ровно один раз и в порядке.

  

**Примеры:**

  

*   NATS

*   Apache Kafka

*   Amazon EventBridge

*   Amazon SNS

*   Google PubSub

  

---

  

### **Перенос событий (Event Sourcing)**

  

Вместо того чтобы хранить только текущее состояние данных в домене, используется хранилище с дозаписью (append-only store) для записи полной серии действий, выполненных с этими данными. Хранилище действует как система записи (system of record) и может быть использовано для материализации доменных объектов.

  

**Перенос событий против Событийно-ориентированной архитектуры (EDA)**

  

*   **Event Sourcing** — это про использование событий как состояния.

*   **EDA** — это про использование событий для общения между границами сервисов.

  

**Преимущества:**

  

*   Отлично подходит для отчетности в реальном времени.

*   Отличная отказоустойчивость.

*   Предпочтительный способ достижения функциональности аудита.

  

**Недостатки:**

  

*   Требует очень эффективной сетевой инфраструктуры.

*   Требует надежного способа управления форматами сообщений.

  

---

  

### **CQRS (Command and Query Responsibility Segregation)**

  

**CQRS** — это архитектурный шаблон, который разделяет действия системы на команды (commands) и запросы (queries).

  

*   **Команда (Command)** — это инструкция, директива выполнить определенную задачу. Это намерение что-то изменить и не возвращает значение, только указание на успех или неудачу.

*   **Запрос (Query)** — это запрос информации, который не изменяет состояние системы и не вызывает никаких побочных эффектов.

  

**CQRS с Переносом событий (Event Sourcing)**

  

Шаблон CQRS часто используется вместе с шаблоном Event Sourcing.

  

**Преимущества:**

  

*   Позволяет независимо масштабировать рабочие нагрузки чтения и записи.

*   Ближе к бизнес-логике со слабой связью.

  

**Недостатки:**

  

*   Более сложный дизайн приложения.

*   Проблемы с eventual consistency.

  

---

  

### **API Gateway

  

**API Gateway** — это инструмент управления API, который находится между клиентом и набором внутренних сервисов. Это единая точка входа в систему, которая инкапсулирует внутреннюю архитектуру системы и предоставляет API, адаптированный для каждого клиента. Он также несет другие обязанности, такие как аутентификация, мониторинг, балансировка нагрузки, кэширование, регулирование, логирование и т.д.

  

**Зачем он нужен?**

  

Гранулярность API, предоставляемых микросервисами, часто отличается от того, что нужно клиенту. Следовательно, API-шлюз может предоставить единую точку входа для всех клиентов.

  

**Функции:**

  

*   Аутентификация и авторизация

*   Обнаружение сервисов (Service discovery)

*   Обратный прокси (Reverse Proxy)

*   Кэширование

*   Повторные попытки и разрыв цепи (Retry and Circuit breaking)

*   Балансировка нагрузки

*   Логирование, трассировка

*   Составление API (API composition)

*   Ограничение скорости и регулирование (Rate limiting and throttling)

  

**Преимущества:**

  

*   Инкапсулирует внутреннюю структуру API.

*   Упрощает клиентский код.

  

**Недостатки:**

  

*   Возможная единая точка отказа.

*   Может повлиять на производительность.

  

##### **Паттерн Backend For Frontend (BFF)**

  

В паттерне **Backend For Frontend (BFF)** мы создаем отдельные серверные сервисы для использования конкретными клиентскими приложениями или интерфейсами.

  

GraphQL очень хорошо подходит в качестве Backend For Frontend (BFF).

  

**Примеры технологий шлюзов:**

*   Amazon API Gateway

*   Apigee API Gateway

*   Azure API Gateway

*   Kong API Gateway

  

---

  

### **REST, GraphQL, gRPC**

  

##### **REST**

  

**REST API** — это интерфейс программирования приложений, который соответствует ограничениям стиля архитектуры REST.

  

**Концепции:**

  

*   **Ограничения:** Единый интерфейс, клиент-сервер, без состояния (stateless), кэшируемость, многоуровневая система.

*   **HTTP-глаголы:** GET, POST, PUT, DELETE, PATCH.

*   **Коды ответов HTTP:** 2xx - успех, 4xx - ошибка клиента, 5xx - ошибка сервера.

  

**Пример:**

  

Работа с ресурсом `users`:

  

| URI           | HTTP глагол | Описание               |

| ------------- | ----------- | ---------------------- |

| /users        | GET         | Получить всех пользователей |

| /users/{id}   | GET         | Получить пользователя по id |

| /users        | POST        | Добавить нового пользователя |

| /users/{id}   | PATCH       | Обновить пользователя по id |

| /users/{id}   | DELETE      | Удалить пользователя по id |

  

##### **GraphQL**

  

**GraphQL** — это язык запросов и серверная среда выполнения для API, которая отдает приоритет предоставлению клиентам именно тех данных, которые они запрашивают, и ничего больше.

  

**Пример:**

  

Схема:

```graphql

type Query {

  getUser: User

}

type User {

  id: ID

  name: String

  city: String

  state: String

}

```

Запрос клиента:

```graphql

{

  getUser {

    id

    name

    city

  }

}

```

Ответ:

```json

{

  "getUser": {

    "id": 123,

    "name": "Karan",

    "city": "San Francisco"

  }

}

```

  

##### **gRPC**

  

**gRPC** — это современная высокопроизводительная среда удаленного вызова процедур (RPC) с открытым исходным кодом.

  

**Концепции:**

  

*   **Protocol buffers:** Механизм сериализации структурированных данных.

*   **Определение сервиса:** Используется для описания сервиса и методов.

  

**Пример:**

  

Определение в `.proto` файле:

```

service HelloService {

  rpc SayHello (HelloRequest) returns (HelloResponse);

}

message HelloRequest {

  string greeting = 1;

}

message HelloResponse {

  string reply = 1;

}

```

  

---

  

##### **Сравнение REST, GraphQL, gRPC**

  

| Параметр        | REST       | GraphQL    | gRPC       |

|-----------------|------------|------------|------------|

| Связь (Coupling) | Низкая     | Средняя    | Высокая    |

| Частотность (Chattiness) | Высокая    | Низкая     | Средняя    |

| Производительность | Хорошая    | Хорошая    | Отличная   |

| Сложность       | Средняя    | Высокая    | Низкая     |

| Кэширование     | Отличное   | Кастомное  | Кастомное  |

| Генерация кода  | Плохая     | Хорошая    | Отличная   |

| Обнаружаемость  | Хорошая    | Хорошая    | Плохая     |

| Версионирование | Легкое     | Кастомное  | Сложное    |

  

**Какой API лучше?**

  

Ответ: никакой. Не существует серебряной пули.

  

---

  

### **Long polling, WebSockets, Server-Sent Events (SSE)**

  

##### **Long polling**

  

**HTTP Long polling** — это техника, используемая для как можно более быстрой передачи информации от сервера клиенту.

  

*   **Принцип работы:** Клиент отправляет запрос и ждет ответа. Сервер не отвечает, пока не будут доступны новые данные или не будет достигнут таймаут. Как только клиент получает ответ, он немедленно отправляет новый запрос.

*   **Плюсы:** Простота реализации.

*   **Минусы:** Плохая масштабируемость.

  

##### **WebSockets**

  

**WebSocket** предоставляет полнодуплексные (full-duplex) каналы связи через одно TCP-соединение. Это постоянное соединение между клиентом и сервером.

  

*   **Принцип работы:** Клиент инициирует рукопожатие WebSocket. После установления соединения обе стороны могут обмениваться данными в любое время.

*   **Плюсы:** Полнодуплексная асинхронная связь. Высокая производительность.

*   **Минусы:** Закрытые соединения не восстанавливаются автоматически.

  

##### **Server-Sent Events (SSE)**

  

**Server-Sent Events (SSE)** — это способ установления долгосрочной связи между клиентом и сервером, который позволяет серверу активно передавать данные клиенту.

  

*   **Принцип работы:** Клиент отправляет запрос. Соединение остается открытым. Сервер отправляет данные клиенту, когда они доступны.

*   **Плюсы:** Простота реализации. Поддерживается большинством браузеров.

*   **Минусы:** Однонаправленная связь (только сервер -> клиент).