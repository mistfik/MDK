### **Геохеширование и Квадродеревья (Quadtrees)**

  

##### **Геохеширование (Geohashing)**

  

**Геохеширование** — это метод геокодирования, используемый для кодирования географических координат (таких как широта и долгота) в короткие буквенно-цифровые строки. Он был создан Густаво Нимайером в 2008 году.

  

Например, Сан-Франциско с координатами 37.7564, -122.4016 может быть представлен в виде геохеша `9q8yy9mf`.

  

**Как работает геохеширование?**

  

Геохеш — это иерархический пространственный индекс, который использует кодирование с помощью алфавита Base-32. Первый символ в геохеше идентифицирует начальное местоположение как одну из 32 ячеек. Эта ячейка также будет содержать 32 под-ячейки. Это означает, что для представления точки мир рекурсивно делится на все меньшие и меньшие ячейки с каждым дополнительным битом до достижения желаемой точности. Фактор точности также определяет размер ячейки.

  

Геохеширование гарантирует, что точки пространственно ближе, если их геохеши имеют более длинный общий префикс. Это означает, что чем больше символов в строке, тем точнее местоположение. Например, геохеши `9q8yy9mf` и `9q8yy9vx` находятся близко друг к другу, поскольку они имеют общий префикс `9q8yy9`.

  

Геохеширование также можно использовать для обеспечения определенной степени анонимности, поскольку нам не нужно раскрывать точное местоположение пользователя — в зависимости от длины геохеша мы просто знаем, что он находится где-то в пределах области.

  

Размеры ячеек для геохешей разной длины выглядят следующим образом:

  

| Длина геохеша | Ширина ячейки | Высота ячейки |

| :------------ | :------------ | :------------ |

| 1             | 5000 км       | 5000 км       |

| 2             | 1250 км       | 1250 км       |

| 3             | 156 км        | 156 км        |

| 4             | 39.1 км       | 19.5 км       |

| 5             | 4.89 км       | 4.89 км       |

| 6             | 1.22 км       | 0.61 км       |

| 7             | 153 м         | 153 м         |

| 8             | 38.2 м        | 19.1 м        |

| 9             | 4.77 м        | 4.77 м        |

| 10            | 1.19 м        | 0.596 м       |

| 11            | 149 мм        | 149 мм        |

| 12            | 37.2 мм       | 18.6 мм       |

  

**Примеры использования**

  

Вот некоторые распространенные случаи использования геохеширования:

  

*   Это простой способ представления и хранения местоположения в базе данных.

*   Его можно легко делиться в социальных сетях в виде URL-адресов, так как это проще, чем делиться широтой и долготой.

*   Мы можем эффективно находить ближайших соседей точки с помощью простых строковых сравнений и эффективного поиска по индексам.

  

**Примеры**

  

Геохеширование широко используется и поддерживается популярными базами данных.

  

*   MySQL

*   Redis

*   Amazon DynamoDB

*   Google Cloud Firestore

  

##### **Квадродеревья (Quadtrees)**

  

**Квадродерево** — это древовидная структура данных, в которой каждый внутренний узел имеет ровно четыре дочерних узла. Они часто используются для разделения двумерного пространства путем рекурсивного подразделения его на четыре квадранта или области. Каждый дочерний или листовой узел хранит пространственную информацию. Квадродеревья являются двумерным аналогом октодеревьев (Octrees), которые используются для разделения трехмерного пространства.

  

quadtree

  

**Типы квадродеревьев**

  

Квадродеревья можно классифицировать в соответствии с типом данных, которые они представляют, включая области, точки, линии и кривые. Вот распространенные типы:

  

*   Квадродеревья точек (Point quadtrees)

*   PR-квадродеревья (Point-region quadtrees)

*   PM-квадродеревья (Polygonal map quadtrees)

*   Сжатые квадродеревья (Compressed quadtrees)

*   Квадродеревья ребер (Edge quadtrees)

  

**Зачем нужны квадродеревья?**

  

Разве широты и долготы недостаточно? Зачем нужны квадродеревья? Хотя теоретически, используя широту и долготу, мы можем определить такие вещи, как близость точек друг к другу, используя евклидово расстояние, для практических задач это просто не масштабируемо из-за высокой загрузки ЦП при работе с большими наборами данных.

  

quadtree-subdivision

  

Квадродеревья позволяют нам эффективно искать точки в пределах двумерного диапазона, где эти точки определены как координаты широты/долготы или декартовы координаты (x, y). Кроме того, мы можем сэкономить вычисления, подразделяя узел только после достижения определенного порога. А с применением алгоритмов отображения, таких как кривая Гильберта, мы можем легко повысить производительность запросов по диапазону.

  

**Примеры использования**

  

Вот некоторые распространенные случаи использования квадродеревьев:

  

*   Представление, обработка и сжатие изображений.

*   Пространственное индексирование и запросы по диапазону.

*   Сервисы на основе местоположения, такие как Google Maps, Uber и т.д.

*   Генерация сетки и компьютерная графика.

*   Хранение разреженных данных.

  

---

  

### **Предохранитель (Circuit Breaker)**

  

**Предохранитель (Circuit Breaker)** — это шаблон проектирования, используемый для обнаружения сбоев и инкапсуляции логики предотвращения постоянного повторения сбоя во время технического обслуживания, временного отказа внешней системы или непредвиденных системных трудностей.

  

Основная идея предохранителя очень проста. Мы оборачиваем защищенный вызов функции в объект-предохранитель, который отслеживает сбои. Как только количество сбоев достигает определенного порога, предохранитель "разрывается" (trips), и все последующие вызовы через предохранитель возвращают ошибку, без выполнения защищенного вызова вообще. Обычно мы также хотим получать оповещения от мониторинга, если предохранитель разрывается.

  

**Зачем нужен предохранитель?**

  

Часто программные системы делают удаленные вызовы к ПО, работающему в других процессах, возможно, на других машинах через сеть. Одно из больших различий между вызовами в памяти и удаленными вызовами заключается в том, что удаленные вызовы могут завершиться неудачей или "зависнуть" без ответа до достижения какого-либо таймаута. Что еще хуже, если у нас много вызывающих сторон, обращающихся к неотзывчивому поставщику, мы можем исчерпать критически важные ресурсы, что приведет к каскадным отказам в нескольких системах.

  

**Состояния**

  

Рассмотрим состояния предохранителя:

  

*   **Закрыт (Closed):** Когда все нормально, предохранитель остается закрытым, и все запросы проходят к сервисам в обычном режиме. Если количество сбоев превышает порог, предохранитель разрывается и переходит в состояние "разомкнут".

*   **Разомкнут (Open):** В этом состоянии предохранитель немедленно возвращает ошибку, даже не вызывая сервисы. Предохранитель переходит в состояние "полуразомкнут" после истечения определенного периода таймаута.

*   **Полуразомкнут (Half-Open):** В этом состоянии предохранитель позволяет ограниченному количеству запросов от сервиса пройти и вызвать операцию. Если запросы успешны, предохранитель перейдет в состояние "замкнут". Однако, если запросы продолжают завершаться неудачей, он возвращается в состояние "разомкнут".

  

---

  

### **Ограничение частоты запросов (Rate Limiting)**

  

**Ограничение частоты запросов (Rate Limiting)** означает предотвращение превышения частотой операции определенного лимита. В крупномасштабных системах ограничение частоты обычно используется для защиты базовых сервисов и ресурсов. Rate Limiting обычно используется как защитный механизм в распределенных системах, чтобы общие ресурсы сохраняли доступность. Это также защищает наши API от непреднамеренного или злонамеренного чрезмерного использования, ограничивая количество запросов, которые могут достичь нашего API за заданный период времени.

  

**Зачем нужно ограничение частоты?**

  

Ограничение частоты — очень важная часть любой крупномасштабной системы, и оно может быть использовано для достижения следующих целей:

  

*   Избежать "голодания" ресурсов в результате атак типа "Отказ в обслуживании" (DoS).

*   Помогает контролировать операционные затраты, устанавливая виртуальный предел на автоматическое масштабирование ресурсов, которое, если его не отслеживать, может привести к экспоненциальным счетам.

*   Может использоваться в качестве защиты или смягчения последствий некоторых распространенных атак.

*   Для API, обрабатывающих огромные объемы данных, ограничение частоты может использоваться для управления потоком этих данных.

  

**Алгоритмы**

  

Существуют различные алгоритмы для ограничения частоты запросов к API, каждый со своими преимуществами и недостатками. Кратко обсудим некоторые из них:

  

*   **Протекающее ведро (Leaky Bucket):** Алгоритм, который предоставляет простой, интуитивно понятный подход к ограничению частоты с помощью очереди.

*   **Ведро с токенами (Token Bucket):** Здесь используется концепция "ведра". Когда приходит запрос, из ведра должен быть взят и обработан "токен".

*   **Фиксированное окно (Fixed Window):** Система использует размер окна в n секунд для отслеживания частоты.

*   **Скользящий лог (Sliding Log):** Включает отслеживание журнала с временными метками для каждого запроса.

*   **Скользящее окно (Sliding Window):** Гибридный подход, который сочетает низкую стоимость обработки алгоритма с фиксированным окном и улучшенные граничные условия скользящего лога.

  

**Ограничение частоты в распределенных системах**

  

Ограничение частоты усложняется, когда речь идет о распределенных системах. Две основные проблемы:

  

1.  **Несогласованность (Inconsistencies):** При использовании кластера из нескольких узлов нам может потребоваться применять глобальную политику ограничения частоты.

2.  **Состояние гонки (Race Conditions):** Эта проблема возникает, когда мы используем наивный подход "get-then-set".

  

Решения могут включать использование "липких" сессий (sticky sessions) или централизованного хранилища данных, такого как Redis, с осторожным отношением к состоянию гонки (например, использование атомарных операций или блокировок).

  

---

  

### **Обнаружение сервисов (Service Discovery)**

  

**Обнаружение сервисов (Service Discovery)** — это обнаружение сервисов в компьютерной сети. Протокол обнаружения сервисов (SDP) — это сетевой стандарт, который выполняет обнаружение сетей путем идентификации ресурсов.

  

**Зачем нужно обнаружение сервисов?**

  

В монолитном приложении сервисы вызывают друг друга через методы или процедурные вызовы на уровне языка. Однако современные приложения на основе микросервисов обычно работают в виртуализованных или контейнеризированных средах, где количество экземпляров сервиса и их местоположение изменяются динамически. Следовательно, нам нужен механизм, который позволяет клиентам сервиса делать запросы к динамически изменяющемуся набору кратковременных экземпляров сервисов.

  

**Реализации**

  

Существует два основных шаблона обнаружения сервисов:

  

*   **Обнаружение на стороне клиента (Client-side discovery):** Клиент получает местоположение другого сервиса, запрашивая **реестр сервисов (Service Registry)**.

*   **Обнаружение на стороне сервера (Server-side discovery):** Мы используем промежуточный компонент, такой как балансировщик нагрузки.

  

**Реестр сервисов (Service Registry)**

  

**Реестр сервисов** — это, по сути, база данных, содержащая сетевые адреса экземпляров сервисов, к которым могут обращаться клиенты. Реестр сервисов должен быть высокодоступным и актуальным.

  

**Регистрация сервисов (Service Registration)**

  

Существует два подхода к регистрации сервисов:

  

*   **Саморегистрация (Self-Registration):** Экземпляр сервиса сам отвечает за регистрацию и снятие с учета в Реестре сервисов.

*   **Регистрация через третью сторону (Third-party Registration):** Реестр сам отслеживает изменения запущенных экземпляров, опрашивая среду развертывания или подписываясь на события.

  

**Сервисная сетка (Service Mesh)**

  

**Сервисная сетка (Service Mesh)** обеспечивает управляемую, наблюдаемую и безопасную связь между отдельными сервисами. Она работает вместе с протоколом обнаружения сервисов.

  

**Примеры**

  

Распространенные инструменты для обнаружения сервисов:

*   etcd

*   Consul

*   Apache Thrift

*   Apache Zookeeper

  

---

  

### **SLA, SLO, SLI**

  

Давайте кратко обсудим SLA, SLO и SLI. Они в основном связаны с бизнесом и надежностью сайтов (SRE), но их полезно знать.

  

**Почему они важны?**

  

SLA, SLO и SLI позволяют компаниям определять, отслеживать и контролировать обещания, данные пользователям сервиса. Вместе они должны помогать командам укреплять доверие пользователей к их сервисам с дополнительным акцентом на непрерывное улучшение процессов управления инцидентами и реагирования на них.

  

*   **SLA (Service Level Agreement):** Соглашение об уровне обслуживания — это соглашение между компанией и пользователями данного сервиса.

*   **SLO (Service Level Objective):** Цель уровня обслуживания — это конкретное обещание, которое компания дает пользователям в отношении определенной метрики.

*   **SLI (Service Level Indicator):** Индикатор уровня обслуживания — это ключевая метрика, используемая для определения того, выполняется ли SLO.

  

---

  

### **Аварийное восстановление (Disaster Recovery)**

  

**Аварийное восстановление (DR)** — это процесс восстановления доступа и функциональности инфраструктуры после таких событий, как стихийные бедствия, кибератаки или даже сбои в бизнесе.

  

**Почему аварийное восстановление важно?**

  

*   Минимизирует простои.

*   Ограничивает ущерб.

*   Обеспечивает быстрое восстановление.

*   Улучшает удержание клиентов.

  

**Термины**

  

*   **RTO (Recovery Time Objective):** Целевое время восстановления — максимально допустимая задержка между прерыванием обслуживания и его восстановлением.

*   **RPO (Recovery Point Objective):** Целевая точка восстановления — максимально допустимый промежуток времени с момента последней точки восстановления данных.

  

**Стратегии**

  

*   **Резервное копирование (Back-up):** Самый простой тип.

*   **Холодный сайт (Cold Site):** Организация настраивает базовую инфраструктуру на втором сайте.

*   **Горячий сайт (Hot site):** Поддерживает актуальные копии данных все время.

  

---

  

### **Виртуальные машины (VMs) и Контейнеры**

  

##### **Виртуальные машины (VM)**

  

**Виртуальная машина (VM)** — это вирутальная среда, которая функционирует как виртуальная компьютерная система со своим собственным ЦП, памятью, сетевым интерфейсом и хранилищем, созданная на физической аппаратной системе. Программное обеспечение, называемое **гипервизором (Hypervisor)**, отделяет ресурсы машины от оборудования и предоставляет их для использования ВМ.

  

**Зачем использовать виртуальные машины?**

  

*   **Консолидация серверов:** Размещение многих виртуальных серверов на одном физическом сервере для улучшения утилизации оборудования.

*   **Изоляция:** Среда ВМ изолирована от остальной системы.

  

##### **Контейнеры**

  

**Контейнер** — это стандартная единица программного обеспечения, которая упаковывает код и все его зависимости, чтобы приложение работало быстро и надежно в разных вычислительных средах.

  

**Зачем нужны контейнеры?**

  

*   Разделение ответственности.

*   Переносимость рабочих нагрузок.

*   Изоляция приложений.

*   Гибкая разработка (Agile development).

*   Эффективная эксплуатация.

  

**Виртуализация против Контейнеризации**

  

*   **Виртуализация:** Гипервизор виртуализирует физическое оборудование. Каждая ВМ содержит гостевую ОС, виртуальную копию оборудования и приложение со своими библиотеками.

*   **Контейнеризация:** Контейнеры виртуализируют операционную систему, поэтому каждый контейнер содержит только приложение и его зависимости. Контейнеры совместно используют ядро ОС.

  

---

  

### **OAuth 2.0 и OpenID Connect (OIDC)**

  

##### **OAuth 2.0**

  

**OAuth 2.0** (Open Authorization) — это стандарт, предназначенный для предоставления санкционированного доступа к ресурсам от имени пользователя, без раскрытия учетных данных пользователя. OAuth 2.0 — это протокол **авторизации**, а не аутентификации.

  

**Сущности:**

  

*   Владелец ресурса (Resource Owner)

*   Клиент (Client)

*   Сервер авторизации (Authorization Server)

*   Сервер ресурсов (Resource Server)

*   Области видимости (Scopes)

*   Токен доступа (Access Token)

  

**Как работает OAuth 2.0?**

  

1.  Клиент запрашивает авторизацию у Сервера авторизации.

2.  Сервер авторизации аутентифицирует клиента и проверяет области видимости.

3.  Владелец ресурса взаимодействует с сервером авторизации, чтобы предоставить доступ.

4.  Сервер авторизации перенаправляет обратно к клиенту с кодом авторизации или токеном доступа.

5.  С токеном доступа клиент запрашивает доступ к ресурсу у Сервера ресурсов.

  

**Недостатки OAuth 2.0:**

  

*   Отсутствие встроенных функций безопасности.

*   Нет стандартной реализации.

  

##### **OpenID Connect (OIDC)**

  

**OpenID Connect (OIDC)** — это тонкий слой поверх OAuth 2.0, который добавляет информацию о входе в систему и профиле пользователя, который вошел в систему. Когда Сервер авторизации поддерживает OIDC, его иногда называют **Поставщиком удостоверений (Identity Provider - IdP)**.

  

**Отличие от OAuth 2.0:** Основное отличие заключается в том, что токен предоставляется в формате **JWT (JSON Web Token)**, который содержит стандартизированную информацию о пользователе.

  

---

  

### **Единый вход (Single Sign-On - SSO)**

  

**Единый вход (SSO)** — это процесс аутентификации, при котором пользователь получает доступ к нескольким приложениям или веб-сайтам, используя только один набор учетных данных для входа.

  

**Компоненты**

  

*   **Поставщик удостоверений (Identity Provider - IdP):** Централизованная система, которая хранит и управляет информацией о пользователях и выполняет аутентификацию.

*   **Поставщик услуг (Service Provider):** Приложение или служба, к которой пользователь хочет получить доступ.

*   **Брокер удостоверений (Identity Broker):** Посредник, соединяющий несколько поставщиков услуг с различными поставщиками удостоверений.

  

**SAML**

  

**SAML (Security Assertion Markup Language)** — это открытый стандарт, позволяющий обмениваться информацией о безопасности. SAML реализован с использованием стандарта **XML**.

  

**Как работает SSO?**

  

1.  Пользователь запрашивает ресурс из приложения.

2.  Приложение перенаправляет пользователя к Поставщику удостоверений (IdP).

3.  Пользователь входит с помощью своих учетных данных.

4.  Поставщик удостоверений (IdP) отправляет ответ SSO обратно в приложение.

5.  Приложение предоставляет доступ пользователю.

  

**SAML против OAuth 2.0 и OIDC**

  

| Параметр | SAML | OAuth 2.0 / OIDC |

| :--- | :--- | :--- |

| **Формат** | XML | JSON |

| **Основная цель** | Аутентификация (для предприятий) | Авторизация (OAuth) + Аутентификация (OIDC) |

| **Среда** | Веб-браузеры, корпоративные приложения | Современные веб-приложения, мобильные приложения |

| **Сложность** | Более сложный | Более простой и удобный для разработчиков |

  

**Преимущества SSO:**

  

*   Удобство (один пароль).

*   Упрощение управления.

*   Повышенная безопасность и соответствие требованиям.

  

**Недостатки SSO:**

  

*   Уязвимость единого пароля.

*   Более медленный процесс аутентификации.

  

**Примеры Поставщиков удостоверений (IdP):**

  

*   Okta

*   Google

*   Auth0

*   OneLogin

  

---

  

### **SSL, TLS, mTLS**

  

##### **SSL (Secure Sockets Layer)**

  

**SSL** — это протокол для шифрования и защиты интернет-соединений. Был разработан в 1995 году, но с тех пор признан устаревшим в пользу TLS. Однако сертификаты до сих пор часто называют "SSL-сертификатами".

  

##### **TLS (Transport Layer Security)**

  

**TLS** — широко принятый протокол безопасности, предназначенный для обеспечения конфиденциальности и безопасности данных при общении через Интернет. TLS развился из SSL.

  

**Три основные цели TLS:**

  

1.  **Шифрование (Encryption):** скрывает передаваемые данные от третьих лиц.

2.  **Аутентификация (Authentication):** гарантирует, что стороны, обменивающиеся информацией, являются теми, за кого себя выдают.

3.  **Целостность (Integrity):** проверяет, что данные не были подделаны или изменены.

  

##### **mTLS (Mutual TLS)**

  

**Взаимный TLS (mTLS)** — это метод взаимной аутентификации. mTLS гарантирует, что стороны на каждом конце сетевого соединения являются теми, за кого себя выдают, проверяя, что у обеих есть правильный закрытый ключ.

  

**Зачем использовать mTLS?**

  

mTLS помогает обеспечить безопасность и доверенность трафика в *обоих направлениях* между клиентом и сервером. Это особенно полезно в микросервисных архитектурах и для устройств Интернета вещей (IoT) в моделях безопасности с нулевым доверием (Zero Trust).